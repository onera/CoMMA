<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CoMMA: CoMMA_lib/Util.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CoMMA<span id="projectnumber">&#160;v1.3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('_util_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Util.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;algorithm&gt;</code><br />
<code>#include &lt;cassert&gt;</code><br />
<code>#include &lt;cmath&gt;</code><br />
<code>#include &lt;functional&gt;</code><br />
<code>#include &lt;iterator&gt;</code><br />
<code>#include &lt;numeric&gt;</code><br />
<code>#include &lt;queue&gt;</code><br />
<code>#include &lt;unordered_map&gt;</code><br />
<code>#include &lt;unordered_set&gt;</code><br />
<code>#include &lt;utility&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
</div>
<p><a href="_util_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_custom_pair_less_functor.html">CustomPairLessFunctor&lt; PairT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor for pairs implementing a custom 'less than'. It relies on the 'less than' operator for the second elements and 'greater than' for the first ones.  <a href="struct_custom_pair_less_functor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_custom_pair_greater_functor.html">CustomPairGreaterFunctor&lt; PairT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor for pairs implementing a custom 'greater than'. It relies on the 'greater than' operator for the second elements and 'less than' for the first ones.  <a href="struct_custom_pair_greater_functor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_pair_second_based_less_functor.html">PairSecondBasedLessFunctor&lt; PairT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor for pairs implementing a less operator based only on the second element of the pair.  <a href="struct_pair_second_based_less_functor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pair_find_first_based_functor.html">PairFindFirstBasedFunctor&lt; PairT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor implementing an operator telling if a given value if the first one of pair.  <a href="class_pair_find_first_based_functor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a8084ea35afd15dd36dacfc54e6f8ff90"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_util_8h.html#a8084ea35afd15dd36dacfc54e6f8ff90">CoMMAUnused</a>(var)&#160;&#160;&#160;(void)(var)</td></tr>
<tr class="memdesc:a8084ea35afd15dd36dacfc54e6f8ff90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient function to avoid unused warnings.  <a href="_util_8h.html#a8084ea35afd15dd36dacfc54e6f8ff90">More...</a><br /></td></tr>
<tr class="separator:a8084ea35afd15dd36dacfc54e6f8ff90"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aeec73ae34bff3c397b99dcf03d14a4a5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeec73ae34bff3c397b99dcf03d14a4a5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_util_8h.html#aeec73ae34bff3c397b99dcf03d14a4a5">dot_deviate</a> (const T dot)</td></tr>
<tr class="memdesc:aeec73ae34bff3c397b99dcf03d14a4a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell whether the dot product given as input comes from two parallel vectors. Compared against <a class="el" href="_util_8h.html#a92bafb9d36c34646ee1bf8ec1c67f3c9">deviate_thresh</a>.  <a href="_util_8h.html#aeec73ae34bff3c397b99dcf03d14a4a5">More...</a><br /></td></tr>
<tr class="separator:aeec73ae34bff3c397b99dcf03d14a4a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f46b4dab5ae23f1a86a2c55c2a6beb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a92f46b4dab5ae23f1a86a2c55c2a6beb"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_util_8h.html#a92f46b4dab5ae23f1a86a2c55c2a6beb">dot_product</a> (const vector&lt; T &gt; &amp;a, const vector&lt; T &gt; &amp;b)</td></tr>
<tr class="memdesc:a92f46b4dab5ae23f1a86a2c55c2a6beb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the dot product between two vectors. No check on size is performed.  <a href="_util_8h.html#a92f46b4dab5ae23f1a86a2c55c2a6beb">More...</a><br /></td></tr>
<tr class="separator:a92f46b4dab5ae23f1a86a2c55c2a6beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c9ba8185d11790d9d1a4e466d98a35"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a40c9ba8185d11790d9d1a4e466d98a35"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_util_8h.html#a40c9ba8185d11790d9d1a4e466d98a35">get_direction</a> (const vector&lt; T &gt; &amp;a, const vector&lt; T &gt; &amp;b, vector&lt; T &gt; &amp;dir)</td></tr>
<tr class="memdesc:a40c9ba8185d11790d9d1a4e466d98a35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the direction from point <code>a</code> to point <code>b</code> and store it as unit vector in <code>dir</code>.  <a href="_util_8h.html#a40c9ba8185d11790d9d1a4e466d98a35">More...</a><br /></td></tr>
<tr class="separator:a40c9ba8185d11790d9d1a4e466d98a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cbf9d2aae5e1f86e108538e5baa10f8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4cbf9d2aae5e1f86e108538e5baa10f8"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_util_8h.html#a4cbf9d2aae5e1f86e108538e5baa10f8">squared_euclidean_distance</a> (const vector&lt; T &gt; &amp;a, const vector&lt; T &gt; &amp;b)</td></tr>
<tr class="memdesc:a4cbf9d2aae5e1f86e108538e5baa10f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the squared Euclidean distance between two points seen as vectors. We use vectors because we can have both 2- and 3D points (also we can have 3D points even if the dimension given to CoMMA is 2D, e.g., with CODA pseudo-2D meshes). The dimension used as reference is the one of the first point.  <a href="_util_8h.html#a4cbf9d2aae5e1f86e108538e5baa10f8">More...</a><br /></td></tr>
<tr class="separator:a4cbf9d2aae5e1f86e108538e5baa10f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eb847819a7f5df06f9de67ff7dff82a"><td class="memTemplParams" colspan="2">template&lt;typename CoMMAContainerPairType &gt; </td></tr>
<tr class="memitem:a4eb847819a7f5df06f9de67ff7dff82a"><td class="memTemplItemLeft" align="right" valign="top">vector&lt; typename CoMMAContainerPairType::value_type::first_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_util_8h.html#a4eb847819a7f5df06f9de67ff7dff82a">vector_of_first_elements</a> (const CoMMAContainerPairType &amp;c)</td></tr>
<tr class="memdesc:a4eb847819a7f5df06f9de67ff7dff82a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a container of pairs, return a vector with first elements only.  <a href="_util_8h.html#a4eb847819a7f5df06f9de67ff7dff82a">More...</a><br /></td></tr>
<tr class="separator:a4eb847819a7f5df06f9de67ff7dff82a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f9e797856aaddc8607e26502cea3658"><td class="memTemplParams" colspan="2">template&lt;typename KeyT , typename ValueT &gt; </td></tr>
<tr class="memitem:a0f9e797856aaddc8607e26502cea3658"><td class="memTemplItemLeft" align="right" valign="top">unordered_set&lt; KeyT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_util_8h.html#a0f9e797856aaddc8607e26502cea3658">d_keys_to_set</a> (const unordered_map&lt; KeyT, ValueT &gt; &amp;dict)</td></tr>
<tr class="memdesc:a0f9e797856aaddc8607e26502cea3658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function for creating a set out of the keys of a map.  <a href="_util_8h.html#a0f9e797856aaddc8607e26502cea3658">More...</a><br /></td></tr>
<tr class="separator:a0f9e797856aaddc8607e26502cea3658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a391837a2e1b572f5f7926b9aaae04d44"><td class="memTemplParams" colspan="2">template&lt;typename IndexT , typename DistT &gt; </td></tr>
<tr class="memitem:a391837a2e1b572f5f7926b9aaae04d44"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_util_8h.html#a391837a2e1b572f5f7926b9aaae04d44">compute_neighbourhood_based_wall_distance</a> (const vector&lt; IndexT &gt; &amp;neigh_idxs, const vector&lt; IndexT &gt; &amp;neighs, const vector&lt; IndexT &gt; &amp;wall, vector&lt; DistT &gt; &amp;dist)</td></tr>
<tr class="memdesc:a391837a2e1b572f5f7926b9aaae04d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a neighbourhood-base wall-distance, that is, the distance of a given cell from a wall is the number of cells though which the minimum path starting from the cell and ending at the wall. For example, in a Cartesian grids this is equivalent to the minimum of the Manhattan distance.<br  />
 If the vector defining the wall is empty, return negative values.<br  />
 If a cell is unconnected to the domain with the wall, its distance will be negative.<br  />
 It takes a compressed version of the connectivity of the mesh. It uses a BFS algorithm to visit all the cells.  <a href="_util_8h.html#a391837a2e1b572f5f7926b9aaae04d44">More...</a><br /></td></tr>
<tr class="separator:a391837a2e1b572f5f7926b9aaae04d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a92bafb9d36c34646ee1bf8ec1c67f3c9"><td class="memItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_util_8h.html#a92bafb9d36c34646ee1bf8ec1c67f3c9">deviate_thresh</a> = 0.9396926207859084</td></tr>
<tr class="memdesc:a92bafb9d36c34646ee1bf8ec1c67f3c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Threshold used in combination with a dot product to tell whether two vector deviate. It is set to <picture><source srcset="form_4_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \cos(20^\circ) $" src="form_4.png"/></picture>.  <a href="_util_8h.html#a92bafb9d36c34646ee1bf8ec1c67f3c9">More...</a><br /></td></tr>
<tr class="separator:a92bafb9d36c34646ee1bf8ec1c67f3c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a8084ea35afd15dd36dacfc54e6f8ff90" name="a8084ea35afd15dd36dacfc54e6f8ff90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8084ea35afd15dd36dacfc54e6f8ff90">&#9670;&#160;</a></span>CoMMAUnused</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CoMMAUnused</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">var</td><td>)</td>
          <td>&#160;&#160;&#160;(void)(var)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenient function to avoid unused warnings. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a391837a2e1b572f5f7926b9aaae04d44" name="a391837a2e1b572f5f7926b9aaae04d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a391837a2e1b572f5f7926b9aaae04d44">&#9670;&#160;</a></span>compute_neighbourhood_based_wall_distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexT , typename DistT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void compute_neighbourhood_based_wall_distance </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; IndexT &gt; &amp;&#160;</td>
          <td class="paramname"><em>neigh_idxs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; IndexT &gt; &amp;&#160;</td>
          <td class="paramname"><em>neighs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; IndexT &gt; &amp;&#160;</td>
          <td class="paramname"><em>wall</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; DistT &gt; &amp;&#160;</td>
          <td class="paramname"><em>dist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a neighbourhood-base wall-distance, that is, the distance of a given cell from a wall is the number of cells though which the minimum path starting from the cell and ending at the wall. For example, in a Cartesian grids this is equivalent to the minimum of the Manhattan distance.<br  />
 If the vector defining the wall is empty, return negative values.<br  />
 If a cell is unconnected to the domain with the wall, its distance will be negative.<br  />
 It takes a compressed version of the connectivity of the mesh. It uses a BFS algorithm to visit all the cells. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IndexT</td><td>Type for cell indices </td></tr>
    <tr><td class="paramname">DistT</td><td>Type for distance (should be signed) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">neigh_idxs</td><td>Indices used to recover the neighbours of each cells provided in <code>neighs</code>. The length is <picture><source srcset="form_5_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ N_{cells} + 1 $" src="form_5.png"/></picture> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">neighs</td><td>Neighbours of the cells </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wall</td><td>Cells composing the wall from which the distance is computed </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dist</td><td>Distance from the wall. This vector is resized inside the function to hold all the cells </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is <b>experimental</b>. Moreover, since CoMMA has knoledge of the current domain only, this function might not give the right result if the domain hab been partitioned. It is advised to use this function only when considering one domain only. </dd></dl>

</div>
</div>
<a id="a0f9e797856aaddc8607e26502cea3658" name="a0f9e797856aaddc8607e26502cea3658"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f9e797856aaddc8607e26502cea3658">&#9670;&#160;</a></span>d_keys_to_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT , typename ValueT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unordered_set&lt; KeyT &gt; d_keys_to_set </td>
          <td>(</td>
          <td class="paramtype">const unordered_map&lt; KeyT, ValueT &gt; &amp;&#160;</td>
          <td class="paramname"><em>dict</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function for creating a set out of the keys of a map. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyT</td><td>Type of the keys of the map </td></tr>
    <tr><td class="paramname">ValueT</td><td>Type of the values of the map </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dict</td><td>A map </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a set </dd></dl>

</div>
</div>
<a id="aeec73ae34bff3c397b99dcf03d14a4a5" name="aeec73ae34bff3c397b99dcf03d14a4a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeec73ae34bff3c397b99dcf03d14a4a5">&#9670;&#160;</a></span>dot_deviate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool dot_deviate </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>dot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tell whether the dot product given as input comes from two parallel vectors. Compared against <a class="el" href="_util_8h.html#a92bafb9d36c34646ee1bf8ec1c67f3c9">deviate_thresh</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Input type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dot</td><td>Dot product </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if higher than a reference threshold </dd></dl>

</div>
</div>
<a id="a92f46b4dab5ae23f1a86a2c55c2a6beb" name="a92f46b4dab5ae23f1a86a2c55c2a6beb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92f46b4dab5ae23f1a86a2c55c2a6beb">&#9670;&#160;</a></span>dot_product()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T dot_product </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the dot product between two vectors. No check on size is performed. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Input type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>First vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Second vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the dot product </dd></dl>

</div>
</div>
<a id="a40c9ba8185d11790d9d1a4e466d98a35" name="a40c9ba8185d11790d9d1a4e466d98a35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40c9ba8185d11790d9d1a4e466d98a35">&#9670;&#160;</a></span>get_direction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T get_direction </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>dir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the direction from point <code>a</code> to point <code>b</code> and store it as unit vector in <code>dir</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Input type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Starting point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>End point </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dir</td><td>Unit vector of the direction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the distance from the two points (the norm used for the normalization) </dd></dl>

</div>
</div>
<a id="a4cbf9d2aae5e1f86e108538e5baa10f8" name="a4cbf9d2aae5e1f86e108538e5baa10f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cbf9d2aae5e1f86e108538e5baa10f8">&#9670;&#160;</a></span>squared_euclidean_distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T squared_euclidean_distance </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the squared Euclidean distance between two points seen as vectors. We use vectors because we can have both 2- and 3D points (also we can have 3D points even if the dimension given to CoMMA is 2D, e.g., with CODA pseudo-2D meshes). The dimension used as reference is the one of the first point. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type for real numbers </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>First point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Second point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The squared Euclidean distance between the two points </dd></dl>

</div>
</div>
<a id="a4eb847819a7f5df06f9de67ff7dff82a" name="a4eb847819a7f5df06f9de67ff7dff82a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eb847819a7f5df06f9de67ff7dff82a">&#9670;&#160;</a></span>vector_of_first_elements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAContainerPairType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; typename CoMMAContainerPairType::value_type::first_type &gt; vector_of_first_elements </td>
          <td>(</td>
          <td class="paramtype">const CoMMAContainerPairType &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a container of pairs, return a vector with first elements only. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CoMMAContainerPairType</td><td>Type of the input container </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>A container of pairs from which the first elements will be extracted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first elements of each pair </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a92bafb9d36c34646ee1bf8ec1c67f3c9" name="a92bafb9d36c34646ee1bf8ec1c67f3c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92bafb9d36c34646ee1bf8ec1c67f3c9">&#9670;&#160;</a></span>deviate_thresh</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr double deviate_thresh = 0.9396926207859084</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Threshold used in combination with a dot product to tell whether two vector deviate. It is set to <picture><source srcset="form_4_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \cos(20^\circ) $" src="form_4.png"/></picture>. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_f7d8b6c0f4428b0df38184f730f938dc.html">CoMMA_lib</a></li><li class="navelem"><a class="el" href="_util_8h.html">Util.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
