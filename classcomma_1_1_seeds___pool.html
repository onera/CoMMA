<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CoMMA: comma::Seeds_Pool&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo-CoMMA_70x70.jpg"/></td>
  <td id="projectalign">
   <div id="projectname">CoMMA<span id="projectnumber">&#160;1.3.2</span>
   </div>
   <div id="projectbrief">A geometric agglomerator for unstructured meshes</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classcomma_1_1_seeds___pool.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classcomma_1_1_seeds___pool-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">comma::Seeds_Pool&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Class representing the pool of all the seeds for creating a coarse cell.  
 <a href="classcomma_1_1_seeds___pool.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_seeds___pool_8h_source.html">Seeds_Pool.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for comma::Seeds_Pool&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcomma_1_1_seeds___pool.png" usemap="#comma::Seeds_5FPool_3C_20CoMMAIndexType_2C_20CoMMAWeightType_2C_20CoMMAIntType_20_3E_map" alt=""/>
  <map id="comma::Seeds_5FPool_3C_20CoMMAIndexType_2C_20CoMMAWeightType_2C_20CoMMAIntType_20_3E_map" name="comma::Seeds_5FPool_3C_20CoMMAIndexType_2C_20CoMMAWeightType_2C_20CoMMAIntType_20_3E_map">
<area href="classcomma_1_1_seeds___pool___boundary___priority.html" title="Class representing the pool of all the seeds for creating a coarse cell. This derived class gives hig..." alt="comma::Seeds_Pool_Boundary_Priority&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;" shape="rect" coords="0,56,614,80"/>
<area href="classcomma_1_1_seeds___pool___neighbourhood___priority.html" title="Class representing the pool of all the seeds for creating a coarse cell. This derived class gives hig..." alt="comma::Seeds_Pool_Neighbourhood_Priority&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;" shape="rect" coords="624,56,1238,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a70eb9e8d60f84565604934f31b6c52a3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_seeds___pool.html#a70eb9e8d60f84565604934f31b6c52a3">CoMMAPairType</a> = std::pair&lt; CoMMAIndexType, CoMMAWeightType &gt;</td></tr>
<tr class="memdesc:a70eb9e8d60f84565604934f31b6c52a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of pair.  <a href="classcomma_1_1_seeds___pool.html#a70eb9e8d60f84565604934f31b6c52a3">More...</a><br /></td></tr>
<tr class="separator:a70eb9e8d60f84565604934f31b6c52a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd24f8571c5608afb54cb4f52558635e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_seeds___pool.html#abd24f8571c5608afb54cb4f52558635e">CoMMAQueueType</a> = std::deque&lt; CoMMAIndexType &gt;</td></tr>
<tr class="memdesc:abd24f8571c5608afb54cb4f52558635e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of queue which holds seeds.  <a href="classcomma_1_1_seeds___pool.html#abd24f8571c5608afb54cb4f52558635e">More...</a><br /></td></tr>
<tr class="separator:abd24f8571c5608afb54cb4f52558635e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9da3ca5fd578388aa227af993bb305cf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_seeds___pool.html#a9da3ca5fd578388aa227af993bb305cf">CoMMASetOfPairType</a> = std::set&lt; <a class="el" href="classcomma_1_1_seeds___pool.html#a70eb9e8d60f84565604934f31b6c52a3">CoMMAPairType</a>, <a class="el" href="structcomma_1_1_custom_pair_greater_functor.html">CustomPairGreaterFunctor</a>&lt; <a class="el" href="classcomma_1_1_seeds___pool.html#a70eb9e8d60f84565604934f31b6c52a3">CoMMAPairType</a> &gt; &gt;</td></tr>
<tr class="memdesc:a9da3ca5fd578388aa227af993bb305cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of set of pairs.  <a href="classcomma_1_1_seeds___pool.html#a9da3ca5fd578388aa227af993bb305cf">More...</a><br /></td></tr>
<tr class="separator:a9da3ca5fd578388aa227af993bb305cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1493c48d699131945ffbd173104c900c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_seeds___pool.html#a1493c48d699131945ffbd173104c900c">Seeds_Pool</a> (const std::vector&lt; CoMMAIntType &gt; &amp;n_bnd_faces, const std::vector&lt; CoMMAWeightType &gt; &amp;priority_weights, const bool one_point_init)</td></tr>
<tr class="memdesc:a1493c48d699131945ffbd173104c900c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="classcomma_1_1_seeds___pool.html#a1493c48d699131945ffbd173104c900c">More...</a><br /></td></tr>
<tr class="separator:a1493c48d699131945ffbd173104c900c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7179db66333b68d1229bb8056dedf97d"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_seeds___pool.html#a7179db66333b68d1229bb8056dedf97d">~Seeds_Pool</a> ()=default</td></tr>
<tr class="memdesc:a7179db66333b68d1229bb8056dedf97d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classcomma_1_1_seeds___pool.html#a7179db66333b68d1229bb8056dedf97d">More...</a><br /></td></tr>
<tr class="separator:a7179db66333b68d1229bb8056dedf97d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e4795e11961d437344ff026bdabf2f"><td class="memItemLeft" align="right" valign="top">std::optional&lt; CoMMAIndexType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_seeds___pool.html#ab8e4795e11961d437344ff026bdabf2f">spoil_queue</a> (const std::vector&lt; bool &gt; &amp;is_fc_agglomerated, <a class="el" href="classcomma_1_1_seeds___pool.html#abd24f8571c5608afb54cb4f52558635e">CoMMAQueueType</a> &amp;queue)</td></tr>
<tr class="memdesc:ab8e4795e11961d437344ff026bdabf2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spoil a queue looking for an not-yet-agglomerated seed.  <a href="classcomma_1_1_seeds___pool.html#ab8e4795e11961d437344ff026bdabf2f">More...</a><br /></td></tr>
<tr class="separator:ab8e4795e11961d437344ff026bdabf2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14a19c8ef86507a6b3f0ff73d3b0a86c"><td class="memItemLeft" align="right" valign="top">virtual std::optional&lt; CoMMAIndexType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_seeds___pool.html#a14a19c8ef86507a6b3f0ff73d3b0a86c">choose_new_seed</a> (const std::vector&lt; bool &gt; &amp;is_agglomerated)=0</td></tr>
<tr class="memdesc:a14a19c8ef86507a6b3f0ff73d3b0a86c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Choose a new seed in the pool.  <a href="classcomma_1_1_seeds___pool.html#a14a19c8ef86507a6b3f0ff73d3b0a86c">More...</a><br /></td></tr>
<tr class="separator:a14a19c8ef86507a6b3f0ff73d3b0a86c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a822572a26fb4a9f1efef060d3ecada9f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_seeds___pool.html#a822572a26fb4a9f1efef060d3ecada9f">update</a> (const std::deque&lt; CoMMAIndexType &gt; &amp;new_seeds)=0</td></tr>
<tr class="memdesc:a822572a26fb4a9f1efef060d3ecada9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the provided seeds to a seeds pool queue according to the number of boundary faces.  <a href="classcomma_1_1_seeds___pool.html#a822572a26fb4a9f1efef060d3ecada9f">More...</a><br /></td></tr>
<tr class="separator:a822572a26fb4a9f1efef060d3ecada9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9e0c8f04da45e06e215bd6d262929c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_seeds___pool.html#aeb9e0c8f04da45e06e215bd6d262929c">order_new_seeds_and_update</a> (const std::unordered_set&lt; CoMMAIndexType &gt; &amp;new_seeds)=0</td></tr>
<tr class="memdesc:aeb9e0c8f04da45e06e215bd6d262929c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the provided seeds to a seeds pool queue according to the number of boundary faces. The seeds will be ordered considering their priority weights before being added to the queue.  <a href="classcomma_1_1_seeds___pool.html#aeb9e0c8f04da45e06e215bd6d262929c">More...</a><br /></td></tr>
<tr class="separator:aeb9e0c8f04da45e06e215bd6d262929c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af927ed91e46d30b8571a964b72f206dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_seeds___pool.html#af927ed91e46d30b8571a964b72f206dc">build_queue</a> (const std::vector&lt; bool &gt; &amp;is_fc_agglomerated, const CoMMAIntType target)</td></tr>
<tr class="memdesc:af927ed91e46d30b8571a964b72f206dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the weight-ordered queue of seed for a given target level. A set of (index, weight) pair with special comparator is used to enforced order, then the indices are extracted.  <a href="classcomma_1_1_seeds___pool.html#af927ed91e46d30b8571a964b72f206dc">More...</a><br /></td></tr>
<tr class="separator:af927ed91e46d30b8571a964b72f206dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e128dabb2ee75e11ea2bbcb4b3920e8"><td class="memItemLeft" align="right" valign="top">std::optional&lt; CoMMAIntType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_seeds___pool.html#a0e128dabb2ee75e11ea2bbcb4b3920e8">get_highest_n_bnd_yet_to_agglomerate</a> (const std::vector&lt; bool &gt; &amp;is_fc_agglomerated, const CoMMAIntType expected_max=<a class="el" href="namespacecomma.html#a6676cd5a4d3dbf9141f8c7bc87617be8a39ad49623cc576b66fc391bd2bc1c7cf">CoMMACellT::CORNER</a>) const</td></tr>
<tr class="memdesc:a0e128dabb2ee75e11ea2bbcb4b3920e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the highest number of boundary faces of cells which are not agglomerated yet.  <a href="classcomma_1_1_seeds___pool.html#a0e128dabb2ee75e11ea2bbcb4b3920e8">More...</a><br /></td></tr>
<tr class="separator:a0e128dabb2ee75e11ea2bbcb4b3920e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b81870765d59728538feb0960bbcc5a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_seeds___pool.html#a5b81870765d59728538feb0960bbcc5a">is_empty</a> (CoMMAIntType i_level=<a class="el" href="namespacecomma.html#a6676cd5a4d3dbf9141f8c7bc87617be8a0309283de9cefb87968e32825c3418ec">CoMMACellT::N_CELL_TYPES</a>) const</td></tr>
<tr class="memdesc:a5b81870765d59728538feb0960bbcc5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the default levels we define if the list of the targeted level is empty.  <a href="classcomma_1_1_seeds___pool.html#a5b81870765d59728538feb0960bbcc5a">More...</a><br /></td></tr>
<tr class="separator:a5b81870765d59728538feb0960bbcc5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01f69492190dc641f35e38c748bc84d9"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_seeds___pool.html#a01f69492190dc641f35e38c748bc84d9">need_initialization</a> (const std::vector&lt; bool &gt; &amp;is_agglomerated)=0</td></tr>
<tr class="memdesc:a01f69492190dc641f35e38c748bc84d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the seeds pool need to be initialized.  <a href="classcomma_1_1_seeds___pool.html#a01f69492190dc641f35e38c748bc84d9">More...</a><br /></td></tr>
<tr class="separator:a01f69492190dc641f35e38c748bc84d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a820ecd76d0ab974a69701c9a9df3114e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_seeds___pool.html#a820ecd76d0ab974a69701c9a9df3114e">initialize</a> ()</td></tr>
<tr class="memdesc:a820ecd76d0ab974a69701c9a9df3114e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the seeds pool via a call to its initializator.  <a href="classcomma_1_1_seeds___pool.html#a820ecd76d0ab974a69701c9a9df3114e">More...</a><br /></td></tr>
<tr class="separator:a820ecd76d0ab974a69701c9a9df3114e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab973d98317537bd99b53956103e69ba8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_seeds___pool.html#ab973d98317537bd99b53956103e69ba8">set_top_queue</a> (const CoMMAIntType q_lvl)</td></tr>
<tr class="memdesc:ab973d98317537bd99b53956103e69ba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setter for the top queue member.  <a href="classcomma_1_1_seeds___pool.html#ab973d98317537bd99b53956103e69ba8">More...</a><br /></td></tr>
<tr class="separator:ab973d98317537bd99b53956103e69ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:af94325238592b000a2549eccf7905f58"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; CoMMAIntType &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_seeds___pool.html#af94325238592b000a2549eccf7905f58">_n_bnd_faces</a></td></tr>
<tr class="memdesc:af94325238592b000a2549eccf7905f58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of number of faces on boundary per cell.  <a href="classcomma_1_1_seeds___pool.html#af94325238592b000a2549eccf7905f58">More...</a><br /></td></tr>
<tr class="separator:af94325238592b000a2549eccf7905f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a0d840ac2abaa80ac8d2e5ff80ca9984d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classcomma_1_1_seeds___pool.html#abd24f8571c5608afb54cb4f52558635e">CoMMAQueueType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_seeds___pool.html#a0d840ac2abaa80ac8d2e5ff80ca9984d">_l_of_seeds</a></td></tr>
<tr class="memdesc:a0d840ac2abaa80ac8d2e5ff80ca9984d"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of deque of seeds. For each identifier we have the available seeds. We want the seed to be chosen preferably in the corner, then ridges, valleys and then interiors, see <a class="el" href="namespacecomma.html#a6676cd5a4d3dbf9141f8c7bc87617be8">CoMMACellT</a>.  <a href="classcomma_1_1_seeds___pool.html#a0d840ac2abaa80ac8d2e5ff80ca9984d">More...</a><br /></td></tr>
<tr class="separator:a0d840ac2abaa80ac8d2e5ff80ca9984d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12a6662e2f8e508e852c76f36df1ff17"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; CoMMAWeightType &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_seeds___pool.html#a12a6662e2f8e508e852c76f36df1ff17">_priority_weights</a></td></tr>
<tr class="memdesc:a12a6662e2f8e508e852c76f36df1ff17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weights used to set the order of the seed to choose.  <a href="classcomma_1_1_seeds___pool.html#a12a6662e2f8e508e852c76f36df1ff17">More...</a><br /></td></tr>
<tr class="separator:a12a6662e2f8e508e852c76f36df1ff17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab12ee6a6886337d0a11eff12c9dcda9c"><td class="memItemLeft" align="right" valign="top">std::optional&lt; CoMMAIntType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_seeds___pool.html#ab12ee6a6886337d0a11eff12c9dcda9c">_cur_top_queue</a></td></tr>
<tr class="memdesc:ab12ee6a6886337d0a11eff12c9dcda9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional possibly containing the level (0,1,2,3, see <a class="el" href="classcomma_1_1_seeds___pool.html#a0d840ac2abaa80ac8d2e5ff80ca9984d">Seeds_Pool::_l_of_seeds</a>) of the queue currently being spoiled.  <a href="classcomma_1_1_seeds___pool.html#ab12ee6a6886337d0a11eff12c9dcda9c">More...</a><br /></td></tr>
<tr class="separator:ab12ee6a6886337d0a11eff12c9dcda9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d8be5640d4c3de04958b4aa9e0e75f"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="structcomma_1_1_s_p_initializator.html">SPInitializator</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_seeds___pool.html#ac1d8be5640d4c3de04958b4aa9e0e75f">_initializator</a></td></tr>
<tr class="memdesc:ac1d8be5640d4c3de04958b4aa9e0e75f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to a <a class="el" href="structcomma_1_1_s_p_initializator.html" title="Functor performing the initialization of a seeds pool.">SPInitializator</a>.  <a href="classcomma_1_1_seeds___pool.html#ac1d8be5640d4c3de04958b4aa9e0e75f">More...</a><br /></td></tr>
<tr class="separator:ac1d8be5640d4c3de04958b4aa9e0e75f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename CoMMAIndexType, typename CoMMAWeightType, typename CoMMAIntType&gt;<br />
class comma::Seeds_Pool&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;</div><p >Class representing the pool of all the seeds for creating a coarse cell. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CoMMAIndexType</td><td>the CoMMA index type for the global index of the mesh </td></tr>
    <tr><td class="paramname">CoMMAWeightType</td><td>the CoMMA weight type for the weights (volume or area) of the nodes or edges of the Mesh </td></tr>
    <tr><td class="paramname">CoMMAIntType</td><td>the CoMMA type for integers </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a70eb9e8d60f84565604934f31b6c52a3" name="a70eb9e8d60f84565604934f31b6c52a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70eb9e8d60f84565604934f31b6c52a3">&#9670;&#160;</a></span>CoMMAPairType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomma_1_1_seeds___pool.html">comma::Seeds_Pool</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;::CoMMAPairType =  std::pair&lt;CoMMAIndexType, CoMMAWeightType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of pair. </p>

</div>
</div>
<a id="abd24f8571c5608afb54cb4f52558635e" name="abd24f8571c5608afb54cb4f52558635e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd24f8571c5608afb54cb4f52558635e">&#9670;&#160;</a></span>CoMMAQueueType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomma_1_1_seeds___pool.html">comma::Seeds_Pool</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;::CoMMAQueueType =  std::deque&lt;CoMMAIndexType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of queue which holds seeds. </p>

</div>
</div>
<a id="a9da3ca5fd578388aa227af993bb305cf" name="a9da3ca5fd578388aa227af993bb305cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9da3ca5fd578388aa227af993bb305cf">&#9670;&#160;</a></span>CoMMASetOfPairType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomma_1_1_seeds___pool.html">comma::Seeds_Pool</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;::CoMMASetOfPairType =  std::set&lt;<a class="el" href="classcomma_1_1_seeds___pool.html#a70eb9e8d60f84565604934f31b6c52a3">CoMMAPairType</a>, <a class="el" href="structcomma_1_1_custom_pair_greater_functor.html">CustomPairGreaterFunctor</a>&lt;<a class="el" href="classcomma_1_1_seeds___pool.html#a70eb9e8d60f84565604934f31b6c52a3">CoMMAPairType</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of set of pairs. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1493c48d699131945ffbd173104c900c" name="a1493c48d699131945ffbd173104c900c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1493c48d699131945ffbd173104c900c">&#9670;&#160;</a></span>Seeds_Pool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcomma_1_1_seeds___pool.html">comma::Seeds_Pool</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;::Seeds_Pool </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; CoMMAIntType &gt; &amp;&#160;</td>
          <td class="paramname"><em>n_bnd_faces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; CoMMAWeightType &gt; &amp;&#160;</td>
          <td class="paramname"><em>priority_weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>one_point_init</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n_bnd_faces</td><td>Vector telling how many boundary faces each cell has </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">priority_weights</td><td>Weights used to set the order of the seed to choose </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">one_point_init</td><td>Whether the initialization should be done for the highest boundary level or just for one point </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7179db66333b68d1229bb8056dedf97d" name="a7179db66333b68d1229bb8056dedf97d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7179db66333b68d1229bb8056dedf97d">&#9670;&#160;</a></span>~Seeds_Pool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcomma_1_1_seeds___pool.html">comma::Seeds_Pool</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;::~<a class="el" href="classcomma_1_1_seeds___pool.html">Seeds_Pool</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af927ed91e46d30b8571a964b72f206dc" name="af927ed91e46d30b8571a964b72f206dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af927ed91e46d30b8571a964b72f206dc">&#9670;&#160;</a></span>build_queue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomma_1_1_seeds___pool.html">comma::Seeds_Pool</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;::build_queue </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>is_fc_agglomerated</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CoMMAIntType&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build the weight-ordered queue of seed for a given target level. A set of (index, weight) pair with special comparator is used to enforced order, then the indices are extracted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">is_fc_agglomerated</td><td>Vector of boolean telling whether a face has been agglomerated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>Level of the queue to build. It corresponds to the number of boundary faces </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14a19c8ef86507a6b3f0ff73d3b0a86c" name="a14a19c8ef86507a6b3f0ff73d3b0a86c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14a19c8ef86507a6b3f0ff73d3b0a86c">&#9670;&#160;</a></span>choose_new_seed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::optional&lt; CoMMAIndexType &gt; <a class="el" href="classcomma_1_1_seeds___pool.html">comma::Seeds_Pool</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;::choose_new_seed </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>is_agglomerated</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Choose a new seed in the pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">is_agglomerated</td><td>Vector of booleans telling whether fine cells are agglomerated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New seed </dd></dl>

<p>Implemented in <a class="el" href="classcomma_1_1_seeds___pool___boundary___priority.html#ae970ce201db03dfd873895b9b9e24c5e">comma::Seeds_Pool_Boundary_Priority&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;</a>, and <a class="el" href="classcomma_1_1_seeds___pool___neighbourhood___priority.html#a02b84ea9c154e7475a6952f63595565e">comma::Seeds_Pool_Neighbourhood_Priority&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;</a>.</p>

</div>
</div>
<a id="a0e128dabb2ee75e11ea2bbcb4b3920e8" name="a0e128dabb2ee75e11ea2bbcb4b3920e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e128dabb2ee75e11ea2bbcb4b3920e8">&#9670;&#160;</a></span>get_highest_n_bnd_yet_to_agglomerate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; CoMMAIntType &gt; <a class="el" href="classcomma_1_1_seeds___pool.html">comma::Seeds_Pool</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;::get_highest_n_bnd_yet_to_agglomerate </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>is_fc_agglomerated</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CoMMAIntType&#160;</td>
          <td class="paramname"><em>expected_max</em> = <code><a class="el" href="namespacecomma.html#a6676cd5a4d3dbf9141f8c7bc87617be8a39ad49623cc576b66fc391bd2bc1c7cf">CoMMACellT::CORNER</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the highest number of boundary faces of cells which are not agglomerated yet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">is_fc_agglomerated</td><td>Vector of boolean telling whether a face has been agglomerated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">expected_max</td><td>Expected value. If found, function returns immediately. Defaulted to <a class="el" href="namespacecomma.html#a6676cd5a4d3dbf9141f8c7bc87617be8a39ad49623cc576b66fc391bd2bc1c7cf" title="Corners, three boundary faces.">CoMMACellT::CORNER</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An optional which contains the number of boundary faces if there is at least one cell left to agglomerate </dd></dl>

</div>
</div>
<a id="a820ecd76d0ab974a69701c9a9df3114e" name="a820ecd76d0ab974a69701c9a9df3114e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a820ecd76d0ab974a69701c9a9df3114e">&#9670;&#160;</a></span>initialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomma_1_1_seeds___pool.html">comma::Seeds_Pool</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;::initialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the seeds pool via a call to its initializator. </p>

</div>
</div>
<a id="a5b81870765d59728538feb0960bbcc5a" name="a5b81870765d59728538feb0960bbcc5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b81870765d59728538feb0960bbcc5a">&#9670;&#160;</a></span>is_empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcomma_1_1_seeds___pool.html">comma::Seeds_Pool</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;::is_empty </td>
          <td>(</td>
          <td class="paramtype">CoMMAIntType&#160;</td>
          <td class="paramname"><em>i_level</em> = <code><a class="el" href="namespacecomma.html#a6676cd5a4d3dbf9141f8c7bc87617be8a0309283de9cefb87968e32825c3418ec">CoMMACellT::N_CELL_TYPES</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given the default levels we define if the list of the targeted level is empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i_level</td><td>level of the defined list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a01f69492190dc641f35e38c748bc84d9" name="a01f69492190dc641f35e38c748bc84d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01f69492190dc641f35e38c748bc84d9">&#9670;&#160;</a></span>need_initialization()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classcomma_1_1_seeds___pool.html">comma::Seeds_Pool</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;::need_initialization </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>is_agglomerated</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the seeds pool need to be initialized. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">is_agglomerated</td><td>Vector of booleans telling whether fine cells are agglomerated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A bool </dd></dl>

<p>Implemented in <a class="el" href="classcomma_1_1_seeds___pool___boundary___priority.html#a3e80d6c43797e17da8a2bb3dd33a2f87">comma::Seeds_Pool_Boundary_Priority&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;</a>, and <a class="el" href="classcomma_1_1_seeds___pool___neighbourhood___priority.html#a341847d4bc85427d4ee8c406c7005fa7">comma::Seeds_Pool_Neighbourhood_Priority&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;</a>.</p>

</div>
</div>
<a id="aeb9e0c8f04da45e06e215bd6d262929c" name="aeb9e0c8f04da45e06e215bd6d262929c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb9e0c8f04da45e06e215bd6d262929c">&#9670;&#160;</a></span>order_new_seeds_and_update()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classcomma_1_1_seeds___pool.html">comma::Seeds_Pool</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;::order_new_seeds_and_update </td>
          <td>(</td>
          <td class="paramtype">const std::unordered_set&lt; CoMMAIndexType &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_seeds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add the provided seeds to a seeds pool queue according to the number of boundary faces. The seeds will be ordered considering their priority weights before being added to the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">new_seeds</td><td>Vector of seeds to add </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classcomma_1_1_seeds___pool___boundary___priority.html#a12bb14f9c2daa73a9842c0554919be54">comma::Seeds_Pool_Boundary_Priority&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;</a>, and <a class="el" href="classcomma_1_1_seeds___pool___neighbourhood___priority.html#a8fddbf0ca066c36daf377289806f19b8">comma::Seeds_Pool_Neighbourhood_Priority&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;</a>.</p>

</div>
</div>
<a id="ab973d98317537bd99b53956103e69ba8" name="ab973d98317537bd99b53956103e69ba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab973d98317537bd99b53956103e69ba8">&#9670;&#160;</a></span>set_top_queue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomma_1_1_seeds___pool.html">comma::Seeds_Pool</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;::set_top_queue </td>
          <td>(</td>
          <td class="paramtype">const CoMMAIntType&#160;</td>
          <td class="paramname"><em>q_lvl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Setter for the top queue member. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">q_lvl</td><td>Level of the new top queue </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab8e4795e11961d437344ff026bdabf2f" name="ab8e4795e11961d437344ff026bdabf2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8e4795e11961d437344ff026bdabf2f">&#9670;&#160;</a></span>spoil_queue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; CoMMAIndexType &gt; <a class="el" href="classcomma_1_1_seeds___pool.html">comma::Seeds_Pool</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;::spoil_queue </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>is_fc_agglomerated</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcomma_1_1_seeds___pool.html#abd24f8571c5608afb54cb4f52558635e">CoMMAQueueType</a> &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Spoil a queue looking for an not-yet-agglomerated seed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">is_fc_agglomerated</td><td>Vector of boolean telling whether a face has been agglomerated </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">queue</td><td>The queue to spoil </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An optional which contains the new seed if found </dd></dl>

</div>
</div>
<a id="a822572a26fb4a9f1efef060d3ecada9f" name="a822572a26fb4a9f1efef060d3ecada9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a822572a26fb4a9f1efef060d3ecada9f">&#9670;&#160;</a></span>update()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classcomma_1_1_seeds___pool.html">comma::Seeds_Pool</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;::update </td>
          <td>(</td>
          <td class="paramtype">const std::deque&lt; CoMMAIndexType &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_seeds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add the provided seeds to a seeds pool queue according to the number of boundary faces. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">new_seeds</td><td>Seeds to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>new_seeds is supposed to be already ordered by the priority weight, therefore no check will be performed </dd></dl>

<p>Implemented in <a class="el" href="classcomma_1_1_seeds___pool___boundary___priority.html#adff771d42e189fd9f51ec5ca70c5ad0d">comma::Seeds_Pool_Boundary_Priority&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;</a>, and <a class="el" href="classcomma_1_1_seeds___pool___neighbourhood___priority.html#af2883cfa457dc93928f31d35f7e62a3c">comma::Seeds_Pool_Neighbourhood_Priority&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ab12ee6a6886337d0a11eff12c9dcda9c" name="ab12ee6a6886337d0a11eff12c9dcda9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab12ee6a6886337d0a11eff12c9dcda9c">&#9670;&#160;</a></span>_cur_top_queue</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;CoMMAIntType&gt; <a class="el" href="classcomma_1_1_seeds___pool.html">comma::Seeds_Pool</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;::_cur_top_queue</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Optional possibly containing the level (0,1,2,3, see <a class="el" href="classcomma_1_1_seeds___pool.html#a0d840ac2abaa80ac8d2e5ff80ca9984d">Seeds_Pool::_l_of_seeds</a>) of the queue currently being spoiled. </p>

</div>
</div>
<a id="ac1d8be5640d4c3de04958b4aa9e0e75f" name="ac1d8be5640d4c3de04958b4aa9e0e75f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1d8be5640d4c3de04958b4aa9e0e75f">&#9670;&#160;</a></span>_initializator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="structcomma_1_1_s_p_initializator.html">SPInitializator</a>&lt;CoMMAIndexType, CoMMAWeightType, CoMMAIntType&gt; &gt; <a class="el" href="classcomma_1_1_seeds___pool.html">comma::Seeds_Pool</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;::_initializator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer to a <a class="el" href="structcomma_1_1_s_p_initializator.html" title="Functor performing the initialization of a seeds pool.">SPInitializator</a>. </p>

</div>
</div>
<a id="a0d840ac2abaa80ac8d2e5ff80ca9984d" name="a0d840ac2abaa80ac8d2e5ff80ca9984d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d840ac2abaa80ac8d2e5ff80ca9984d">&#9670;&#160;</a></span>_l_of_seeds</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classcomma_1_1_seeds___pool.html#abd24f8571c5608afb54cb4f52558635e">CoMMAQueueType</a>&gt; <a class="el" href="classcomma_1_1_seeds___pool.html">comma::Seeds_Pool</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;::_l_of_seeds</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List of deque of seeds. For each identifier we have the available seeds. We want the seed to be chosen preferably in the corner, then ridges, valleys and then interiors, see <a class="el" href="namespacecomma.html#a6676cd5a4d3dbf9141f8c7bc87617be8">CoMMACellT</a>. </p>

</div>
</div>
<a id="af94325238592b000a2549eccf7905f58" name="af94325238592b000a2549eccf7905f58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af94325238592b000a2549eccf7905f58">&#9670;&#160;</a></span>_n_bnd_faces</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;CoMMAIntType&gt;&amp; <a class="el" href="classcomma_1_1_seeds___pool.html">comma::Seeds_Pool</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;::_n_bnd_faces</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vector of number of faces on boundary per cell. </p>

</div>
</div>
<a id="a12a6662e2f8e508e852c76f36df1ff17" name="a12a6662e2f8e508e852c76f36df1ff17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12a6662e2f8e508e852c76f36df1ff17">&#9670;&#160;</a></span>_priority_weights</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;CoMMAWeightType&gt;&amp; <a class="el" href="classcomma_1_1_seeds___pool.html">comma::Seeds_Pool</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;::_priority_weights</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Weights used to set the order of the seed to choose. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/CoMMA/<a class="el" href="_seeds___pool_8h_source.html">Seeds_Pool.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacecomma.html">comma</a></li><li class="navelem"><a class="el" href="classcomma_1_1_seeds___pool.html">Seeds_Pool</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
