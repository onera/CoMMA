<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CoMMA: comma::Dual_Graph&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo-CoMMA_70x70.jpg"/></td>
  <td id="projectalign">
   <div id="projectname">CoMMA<span id="projectnumber">&#160;1.3.2</span>
   </div>
   <div id="projectbrief">A geometric agglomerator for unstructured meshes</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classcomma_1_1_dual___graph.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classcomma_1_1_dual___graph-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">comma::Dual_Graph&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A class implementing the CRS global graph representation of the global mesh.  
 <a href="classcomma_1_1_dual___graph.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_dual___graph_8h_source.html">Dual_Graph.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for comma::Dual_Graph&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcomma_1_1_dual___graph.png" usemap="#comma::Dual_5FGraph_3C_20CoMMAIndexType_2C_20CoMMAWeightType_2C_20CoMMAIntType_20_3E_map" alt=""/>
  <map id="comma::Dual_5FGraph_3C_20CoMMAIndexType_2C_20CoMMAWeightType_2C_20CoMMAIntType_20_3E_map" name="comma::Dual_5FGraph_3C_20CoMMAIndexType_2C_20CoMMAWeightType_2C_20CoMMAIntType_20_3E_map">
<area href="classcomma_1_1_graph.html" title="An interface class responsible of storing the cell centered dual graph and of acting on it (it is an ..." alt="comma::Graph&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;" shape="rect" coords="0,0,473,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ab65d0e9268c98fd72916f2eb16ce4ab4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_dual___graph.html#ab65d0e9268c98fd72916f2eb16ce4ab4">BaseClass</a> = <a class="el" href="classcomma_1_1_graph.html">Graph</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;</td></tr>
<tr class="memdesc:ab65d0e9268c98fd72916f2eb16ce4ab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parent class.  <a href="classcomma_1_1_dual___graph.html#ab65d0e9268c98fd72916f2eb16ce4ab4">More...</a><br /></td></tr>
<tr class="separator:ab65d0e9268c98fd72916f2eb16ce4ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4ca69b6d5fa9725246dfc96d85c112"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_dual___graph.html#a9e4ca69b6d5fa9725246dfc96d85c112">CoMMAPairType</a> = std::pair&lt; CoMMAIndexType, CoMMAWeightType &gt;</td></tr>
<tr class="memdesc:a9e4ca69b6d5fa9725246dfc96d85c112"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of pair.  <a href="classcomma_1_1_dual___graph.html#a9e4ca69b6d5fa9725246dfc96d85c112">More...</a><br /></td></tr>
<tr class="separator:a9e4ca69b6d5fa9725246dfc96d85c112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac83b5f3409ccd78654bc747f43e2d6d6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_dual___graph.html#ac83b5f3409ccd78654bc747f43e2d6d6">CoMMASetOfPairType</a> = std::set&lt; <a class="el" href="classcomma_1_1_dual___graph.html#a9e4ca69b6d5fa9725246dfc96d85c112">CoMMAPairType</a>, <a class="el" href="structcomma_1_1_custom_pair_greater_functor.html">CustomPairGreaterFunctor</a>&lt; <a class="el" href="classcomma_1_1_dual___graph.html#a9e4ca69b6d5fa9725246dfc96d85c112">CoMMAPairType</a> &gt; &gt;</td></tr>
<tr class="memdesc:ac83b5f3409ccd78654bc747f43e2d6d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of set of pairs.  <a href="classcomma_1_1_dual___graph.html#ac83b5f3409ccd78654bc747f43e2d6d6">More...</a><br /></td></tr>
<tr class="separator:ac83b5f3409ccd78654bc747f43e2d6d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac24e8e9de0c15af027fe8d1ccd8304d4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_dual___graph.html#ac24e8e9de0c15af027fe8d1ccd8304d4">ContainerIndexType</a> = std::vector&lt; CoMMAIndexType &gt;</td></tr>
<tr class="memdesc:ac24e8e9de0c15af027fe8d1ccd8304d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for containers of indices.  <a href="classcomma_1_1_dual___graph.html#ac24e8e9de0c15af027fe8d1ccd8304d4">More...</a><br /></td></tr>
<tr class="separator:ac24e8e9de0c15af027fe8d1ccd8304d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab61394e58e9019e8d55320e3a2885115"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_dual___graph.html#ab61394e58e9019e8d55320e3a2885115">ContainerWeightType</a> = std::vector&lt; CoMMAWeightType &gt;</td></tr>
<tr class="memdesc:ab61394e58e9019e8d55320e3a2885115"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for containers of weights.  <a href="classcomma_1_1_dual___graph.html#ab61394e58e9019e8d55320e3a2885115">More...</a><br /></td></tr>
<tr class="separator:ab61394e58e9019e8d55320e3a2885115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classcomma_1_1_graph"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classcomma_1_1_graph')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classcomma_1_1_graph.html">comma::Graph&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;</a></td></tr>
<tr class="memitem:ac24e8e9de0c15af027fe8d1ccd8304d4 inherit pub_types_classcomma_1_1_graph"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_graph.html#ac24e8e9de0c15af027fe8d1ccd8304d4">ContainerIndexType</a> = std::vector&lt; CoMMAIndexType &gt;</td></tr>
<tr class="memdesc:ac24e8e9de0c15af027fe8d1ccd8304d4 inherit pub_types_classcomma_1_1_graph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for containers of indices.  <a href="classcomma_1_1_graph.html#ac24e8e9de0c15af027fe8d1ccd8304d4">More...</a><br /></td></tr>
<tr class="separator:ac24e8e9de0c15af027fe8d1ccd8304d4 inherit pub_types_classcomma_1_1_graph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab61394e58e9019e8d55320e3a2885115 inherit pub_types_classcomma_1_1_graph"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_graph.html#ab61394e58e9019e8d55320e3a2885115">ContainerWeightType</a> = std::vector&lt; CoMMAWeightType &gt;</td></tr>
<tr class="memdesc:ab61394e58e9019e8d55320e3a2885115 inherit pub_types_classcomma_1_1_graph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for containers of weights.  <a href="classcomma_1_1_graph.html#ab61394e58e9019e8d55320e3a2885115">More...</a><br /></td></tr>
<tr class="separator:ab61394e58e9019e8d55320e3a2885115 inherit pub_types_classcomma_1_1_graph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a698f1f4f188f408a34625c656038636e inherit pub_types_classcomma_1_1_graph"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_graph.html#a698f1f4f188f408a34625c656038636e">ContainerIndexConstIt</a> = typename ContainerIndexType::const_iterator</td></tr>
<tr class="memdesc:a698f1f4f188f408a34625c656038636e inherit pub_types_classcomma_1_1_graph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for constant iterators of containers of indices.  <a href="classcomma_1_1_graph.html#a698f1f4f188f408a34625c656038636e">More...</a><br /></td></tr>
<tr class="separator:a698f1f4f188f408a34625c656038636e inherit pub_types_classcomma_1_1_graph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a60fc9c014fc5adb267d64e8f4b2bb inherit pub_types_classcomma_1_1_graph"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_graph.html#a33a60fc9c014fc5adb267d64e8f4b2bb">ContainerWeightConstIt</a> = typename ContainerWeightType::const_iterator</td></tr>
<tr class="memdesc:a33a60fc9c014fc5adb267d64e8f4b2bb inherit pub_types_classcomma_1_1_graph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for constant iterators of containers of weights.  <a href="classcomma_1_1_graph.html#a33a60fc9c014fc5adb267d64e8f4b2bb">More...</a><br /></td></tr>
<tr class="separator:a33a60fc9c014fc5adb267d64e8f4b2bb inherit pub_types_classcomma_1_1_graph"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a62db97821210fa0ffa99d3396eecdaae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_dual___graph.html#a62db97821210fa0ffa99d3396eecdaae">Dual_Graph</a> (const CoMMAIndexType &amp;nb_c, const <a class="el" href="classcomma_1_1_dual___graph.html#ac24e8e9de0c15af027fe8d1ccd8304d4">ContainerIndexType</a> &amp;m_crs_row_ptr, const <a class="el" href="classcomma_1_1_dual___graph.html#ac24e8e9de0c15af027fe8d1ccd8304d4">ContainerIndexType</a> &amp;m_crs_col_ind, const <a class="el" href="classcomma_1_1_dual___graph.html#ab61394e58e9019e8d55320e3a2885115">ContainerWeightType</a> &amp;m_crs_values, const <a class="el" href="classcomma_1_1_dual___graph.html#ab61394e58e9019e8d55320e3a2885115">ContainerWeightType</a> &amp;volumes, const std::vector&lt; std::vector&lt; CoMMAWeightType &gt; &gt; &amp;centers, const std::vector&lt; CoMMAIntType &gt; &amp;n_bnd_faces, const CoMMAIntType dimension, const <a class="el" href="classcomma_1_1_dual___graph.html#ac24e8e9de0c15af027fe8d1ccd8304d4">ContainerIndexType</a> &amp;anisotropic_compliant_fc)</td></tr>
<tr class="memdesc:a62db97821210fa0ffa99d3396eecdaae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor of the class.  <a href="classcomma_1_1_dual___graph.html#a62db97821210fa0ffa99d3396eecdaae">More...</a><br /></td></tr>
<tr class="separator:a62db97821210fa0ffa99d3396eecdaae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2ece10214db2a38f54b4c2e4ab4451f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_dual___graph.html#ad2ece10214db2a38f54b4c2e4ab4451f">~Dual_Graph</a> () override=default</td></tr>
<tr class="memdesc:ad2ece10214db2a38f54b4c2e4ab4451f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor of the class.  <a href="classcomma_1_1_dual___graph.html#ad2ece10214db2a38f54b4c2e4ab4451f">More...</a><br /></td></tr>
<tr class="separator:ad2ece10214db2a38f54b4c2e4ab4451f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a020ecb0b3f410b468bbb8e57878bf9aa"><td class="memItemLeft" align="right" valign="top">CoMMAIntType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_dual___graph.html#a020ecb0b3f410b468bbb8e57878bf9aa">get_n_boundary_faces</a> (const CoMMAIndexType idx_c) const</td></tr>
<tr class="memdesc:a020ecb0b3f410b468bbb8e57878bf9aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return how many boundary faces a certain cell has.  <a href="classcomma_1_1_dual___graph.html#a020ecb0b3f410b468bbb8e57878bf9aa">More...</a><br /></td></tr>
<tr class="separator:a020ecb0b3f410b468bbb8e57878bf9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e13a84eed233df574dc50a0b7d3adf5"><td class="memItemLeft" align="right" valign="top">CoMMAIntType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_dual___graph.html#a3e13a84eed233df574dc50a0b7d3adf5">get_total_n_faces</a> (const CoMMAIndexType idx_c) const</td></tr>
<tr class="memdesc:a3e13a84eed233df574dc50a0b7d3adf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return total number of faces, that is, number of neighbours plus number of boundaries.  <a href="classcomma_1_1_dual___graph.html#a3e13a84eed233df574dc50a0b7d3adf5">More...</a><br /></td></tr>
<tr class="separator:a3e13a84eed233df574dc50a0b7d3adf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a243466aae3bc5b1a7c1f259dc398ce67"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_dual___graph.html#a243466aae3bc5b1a7c1f259dc398ce67">is_on_boundary</a> (const CoMMAIndexType idx_c) const</td></tr>
<tr class="memdesc:a243466aae3bc5b1a7c1f259dc398ce67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether a cell is on the boundary.  <a href="classcomma_1_1_dual___graph.html#a243466aae3bc5b1a7c1f259dc398ce67">More...</a><br /></td></tr>
<tr class="separator:a243466aae3bc5b1a7c1f259dc398ce67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4e2cd99bd2e6035febcd49ff460ce3e"><td class="memItemLeft" align="right" valign="top">CoMMAWeightType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_dual___graph.html#af4e2cd99bd2e6035febcd49ff460ce3e">estimated_boundary_weight</a> (const CoMMAIndexType idx_c) const</td></tr>
<tr class="memdesc:af4e2cd99bd2e6035febcd49ff460ce3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate the value of a boundary face using the known internal faces. It uses a (geometric) average, so the result is correct only if the cell is a regular polygon.  <a href="classcomma_1_1_dual___graph.html#af4e2cd99bd2e6035febcd49ff460ce3e">More...</a><br /></td></tr>
<tr class="separator:af4e2cd99bd2e6035febcd49ff460ce3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bed2815c618f5670469a6cb38863f0e"><td class="memItemLeft" align="right" valign="top">CoMMAWeightType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_dual___graph.html#a5bed2815c618f5670469a6cb38863f0e">estimated_total_weight</a> (const CoMMAIndexType idx_c) const</td></tr>
<tr class="memdesc:a5bed2815c618f5670469a6cb38863f0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum of wall the weights (faces) of a cell. Since there is no knowledge about boundary faces, the result is correct only if internal cell.  <a href="classcomma_1_1_dual___graph.html#a5bed2815c618f5670469a6cb38863f0e">More...</a><br /></td></tr>
<tr class="separator:a5bed2815c618f5670469a6cb38863f0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae54c9474438da03527cc8eab80362cf3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_dual___graph.html#ae54c9474438da03527cc8eab80362cf3">tag_anisotropic_cells</a> (<a class="el" href="classcomma_1_1_dual___graph.html#ab61394e58e9019e8d55320e3a2885115">ContainerWeightType</a> &amp;max_weights, std::vector&lt; bool &gt; &amp;is_anisotropic, std::deque&lt; CoMMAIndexType &gt; &amp;aniso_seeds_pool, const CoMMAWeightType threshold_anisotropy, const <a class="el" href="classcomma_1_1_dual___graph.html#ab61394e58e9019e8d55320e3a2885115">ContainerWeightType</a> &amp;priority_weights, const CoMMAIndexType preserving)</td></tr>
<tr class="memdesc:ae54c9474438da03527cc8eab80362cf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag cells as anisotropic if their aspect-ratio is over a given threshold and order them according to given priority.  <a href="classcomma_1_1_dual___graph.html#ae54c9474438da03527cc8eab80362cf3">More...</a><br /></td></tr>
<tr class="separator:ae54c9474438da03527cc8eab80362cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03162eab93fc7ace92992ebea53db274"><td class="memItemLeft" align="right" valign="top">CoMMAIntType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_dual___graph.html#a03162eab93fc7ace92992ebea53db274">get_nb_cells</a> () const</td></tr>
<tr class="memdesc:a03162eab93fc7ace92992ebea53db274"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter that returns the number of cells.  <a href="classcomma_1_1_dual___graph.html#a03162eab93fc7ace92992ebea53db274">More...</a><br /></td></tr>
<tr class="separator:a03162eab93fc7ace92992ebea53db274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e3f45ecd852a941dc39064f7454efb3"><td class="memItemLeft" align="right" valign="top">std::unordered_set&lt; CoMMAIndexType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_dual___graph.html#a7e3f45ecd852a941dc39064f7454efb3">get_neighbourhood_of_cc</a> (const std::unordered_set&lt; CoMMAIndexType &gt; &amp;s_seeds, const std::vector&lt; bool &gt; &amp;is_fc_agglomerated_tmp) const</td></tr>
<tr class="memdesc:a7e3f45ecd852a941dc39064f7454efb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the fine cells neighbours of a coarse cell.  <a href="classcomma_1_1_dual___graph.html#a7e3f45ecd852a941dc39064f7454efb3">More...</a><br /></td></tr>
<tr class="separator:a7e3f45ecd852a941dc39064f7454efb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20485b4e0bddf0fd2e6fe38b5aa7582b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_dual___graph.html#a20485b4e0bddf0fd2e6fe38b5aa7582b">compute_neighbourhood_of_cc</a> (const std::unordered_set&lt; CoMMAIndexType &gt; &amp;s_seeds, CoMMAIntType &amp;nb_of_order_of_neighbourhood, std::unordered_map&lt; CoMMAIndexType, CoMMAIntType &gt; &amp;d_n_of_seed, const CoMMAIntType max_card, const std::vector&lt; bool &gt; &amp;is_fc_agglomerated_tmp) const</td></tr>
<tr class="memdesc:a20485b4e0bddf0fd2e6fe38b5aa7582b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the dictionary of compactness of fine cells inside a coarse cell.  <a href="classcomma_1_1_dual___graph.html#a20485b4e0bddf0fd2e6fe38b5aa7582b">More...</a><br /></td></tr>
<tr class="separator:a20485b4e0bddf0fd2e6fe38b5aa7582b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classcomma_1_1_graph"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classcomma_1_1_graph')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classcomma_1_1_graph.html">comma::Graph&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;</a></td></tr>
<tr class="memitem:a22e0c39a18c9f9bc87cc71c0255b43c0 inherit pub_methods_classcomma_1_1_graph"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_graph.html#a22e0c39a18c9f9bc87cc71c0255b43c0">Graph</a> (const CoMMAIndexType &amp;nb_c, const <a class="el" href="classcomma_1_1_graph.html#ac24e8e9de0c15af027fe8d1ccd8304d4">ContainerIndexType</a> &amp;m_crs_row_ptr, const <a class="el" href="classcomma_1_1_graph.html#ac24e8e9de0c15af027fe8d1ccd8304d4">ContainerIndexType</a> &amp;m_crs_col_ind, const <a class="el" href="classcomma_1_1_graph.html#ab61394e58e9019e8d55320e3a2885115">ContainerWeightType</a> &amp;m_crs_values, const <a class="el" href="classcomma_1_1_graph.html#ab61394e58e9019e8d55320e3a2885115">ContainerWeightType</a> &amp;volumes)</td></tr>
<tr class="memdesc:a22e0c39a18c9f9bc87cc71c0255b43c0 inherit pub_methods_classcomma_1_1_graph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor of the class.  <a href="classcomma_1_1_graph.html#a22e0c39a18c9f9bc87cc71c0255b43c0">More...</a><br /></td></tr>
<tr class="separator:a22e0c39a18c9f9bc87cc71c0255b43c0 inherit pub_methods_classcomma_1_1_graph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7d4773cefcbc9627b0779e28824e1f8 inherit pub_methods_classcomma_1_1_graph"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_graph.html#ad7d4773cefcbc9627b0779e28824e1f8">~Graph</a> ()=default</td></tr>
<tr class="memdesc:ad7d4773cefcbc9627b0779e28824e1f8 inherit pub_methods_classcomma_1_1_graph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor of the class.  <a href="classcomma_1_1_graph.html#ad7d4773cefcbc9627b0779e28824e1f8">More...</a><br /></td></tr>
<tr class="separator:ad7d4773cefcbc9627b0779e28824e1f8 inherit pub_methods_classcomma_1_1_graph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a138b207a27e58bcb238d0a80444ba75b inherit pub_methods_classcomma_1_1_graph"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_graph.html#a138b207a27e58bcb238d0a80444ba75b">DFS</a> (const CoMMAIndexType &amp;i_fc)</td></tr>
<tr class="memdesc:a138b207a27e58bcb238d0a80444ba75b inherit pub_methods_classcomma_1_1_graph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Depth First Search (DFS) recursive function.  <a href="classcomma_1_1_graph.html#a138b207a27e58bcb238d0a80444ba75b">More...</a><br /></td></tr>
<tr class="separator:a138b207a27e58bcb238d0a80444ba75b inherit pub_methods_classcomma_1_1_graph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea451f73bc04c2b88a24a4709f28c21 inherit pub_methods_classcomma_1_1_graph"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_graph.html#aeea451f73bc04c2b88a24a4709f28c21">BFS</a> (const CoMMAIndexType &amp;root)</td></tr>
<tr class="memdesc:aeea451f73bc04c2b88a24a4709f28c21 inherit pub_methods_classcomma_1_1_graph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Breadth First Search (BFS) function.  <a href="classcomma_1_1_graph.html#aeea451f73bc04c2b88a24a4709f28c21">More...</a><br /></td></tr>
<tr class="separator:aeea451f73bc04c2b88a24a4709f28c21 inherit pub_methods_classcomma_1_1_graph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a607fb45d5b133a30bde7725007877743 inherit pub_methods_classcomma_1_1_graph"><td class="memItemLeft" align="right" valign="top">CoMMAIntType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_graph.html#a607fb45d5b133a30bde7725007877743">get_nb_of_neighbours</a> (const CoMMAIndexType i_c) const</td></tr>
<tr class="memdesc:a607fb45d5b133a30bde7725007877743 inherit pub_methods_classcomma_1_1_graph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the number of neighbours.  <a href="classcomma_1_1_graph.html#a607fb45d5b133a30bde7725007877743">More...</a><br /></td></tr>
<tr class="separator:a607fb45d5b133a30bde7725007877743 inherit pub_methods_classcomma_1_1_graph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26a90ddbfdfa7fd05dd068e3b8eb4c9f inherit pub_methods_classcomma_1_1_graph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcomma_1_1_graph.html#ac24e8e9de0c15af027fe8d1ccd8304d4">ContainerIndexType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_graph.html#a26a90ddbfdfa7fd05dd068e3b8eb4c9f">get_neighbours</a> (const CoMMAIndexType &amp;i_c) const</td></tr>
<tr class="memdesc:a26a90ddbfdfa7fd05dd068e3b8eb4c9f inherit pub_methods_classcomma_1_1_graph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Based on the CRS representation retrieves the neighbours of the cell given as an input.  <a href="classcomma_1_1_graph.html#a26a90ddbfdfa7fd05dd068e3b8eb4c9f">More...</a><br /></td></tr>
<tr class="separator:a26a90ddbfdfa7fd05dd068e3b8eb4c9f inherit pub_methods_classcomma_1_1_graph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53c16fecb13a6319a63b681ac470f94 inherit pub_methods_classcomma_1_1_graph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcomma_1_1_graph.html#a698f1f4f188f408a34625c656038636e">ContainerIndexConstIt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_graph.html#ae53c16fecb13a6319a63b681ac470f94">neighbours_cbegin</a> (const CoMMAIndexType &amp;i_c) const</td></tr>
<tr class="memdesc:ae53c16fecb13a6319a63b681ac470f94 inherit pub_methods_classcomma_1_1_graph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get constant pointer to the first neighbour of cell <code>i_c</code>.  <a href="classcomma_1_1_graph.html#ae53c16fecb13a6319a63b681ac470f94">More...</a><br /></td></tr>
<tr class="separator:ae53c16fecb13a6319a63b681ac470f94 inherit pub_methods_classcomma_1_1_graph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49889cfff4e34758c1716d0d43c292d4 inherit pub_methods_classcomma_1_1_graph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcomma_1_1_graph.html#a698f1f4f188f408a34625c656038636e">ContainerIndexConstIt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_graph.html#a49889cfff4e34758c1716d0d43c292d4">neighbours_cend</a> (const CoMMAIndexType &amp;i_c) const</td></tr>
<tr class="memdesc:a49889cfff4e34758c1716d0d43c292d4 inherit pub_methods_classcomma_1_1_graph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get constant pointer to the element following the last neighbour of cell <code>i_c</code>.  <a href="classcomma_1_1_graph.html#a49889cfff4e34758c1716d0d43c292d4">More...</a><br /></td></tr>
<tr class="separator:a49889cfff4e34758c1716d0d43c292d4 inherit pub_methods_classcomma_1_1_graph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec4547e40dba5830f05b5fe96cd2355c inherit pub_methods_classcomma_1_1_graph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcomma_1_1_graph.html#ab61394e58e9019e8d55320e3a2885115">ContainerWeightType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_graph.html#aec4547e40dba5830f05b5fe96cd2355c">get_weights</a> (const CoMMAIndexType &amp;i_c) const</td></tr>
<tr class="memdesc:aec4547e40dba5830f05b5fe96cd2355c inherit pub_methods_classcomma_1_1_graph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Based on the area of the faces composing the cell given as an input, we retrieve the faces connecting the given cell with the neighbourhood that can be described also as the weight of the graph.  <a href="classcomma_1_1_graph.html#aec4547e40dba5830f05b5fe96cd2355c">More...</a><br /></td></tr>
<tr class="separator:aec4547e40dba5830f05b5fe96cd2355c inherit pub_methods_classcomma_1_1_graph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a036c1da6e0297d153c0a1dea0aeee8b9 inherit pub_methods_classcomma_1_1_graph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcomma_1_1_graph.html#a33a60fc9c014fc5adb267d64e8f4b2bb">ContainerWeightConstIt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_graph.html#a036c1da6e0297d153c0a1dea0aeee8b9">weights_cbegin</a> (const CoMMAIndexType &amp;i_c) const</td></tr>
<tr class="memdesc:a036c1da6e0297d153c0a1dea0aeee8b9 inherit pub_methods_classcomma_1_1_graph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get constant pointer to the first neighbour of cell <code>i_c</code>.  <a href="classcomma_1_1_graph.html#a036c1da6e0297d153c0a1dea0aeee8b9">More...</a><br /></td></tr>
<tr class="separator:a036c1da6e0297d153c0a1dea0aeee8b9 inherit pub_methods_classcomma_1_1_graph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9974d87bd1fc67902f8c5fc400a3ad71 inherit pub_methods_classcomma_1_1_graph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcomma_1_1_graph.html#a33a60fc9c014fc5adb267d64e8f4b2bb">ContainerWeightConstIt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_graph.html#a9974d87bd1fc67902f8c5fc400a3ad71">weights_cend</a> (const CoMMAIndexType &amp;i_c) const</td></tr>
<tr class="memdesc:a9974d87bd1fc67902f8c5fc400a3ad71 inherit pub_methods_classcomma_1_1_graph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get constant pointer to the element following the last neighbour of cell <code>i_c</code>.  <a href="classcomma_1_1_graph.html#a9974d87bd1fc67902f8c5fc400a3ad71">More...</a><br /></td></tr>
<tr class="separator:a9974d87bd1fc67902f8c5fc400a3ad71 inherit pub_methods_classcomma_1_1_graph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72c40bec394188475ac30b159388f29f inherit pub_methods_classcomma_1_1_graph"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_graph.html#a72c40bec394188475ac30b159388f29f">check_connectivity</a> ()</td></tr>
<tr class="memdesc:a72c40bec394188475ac30b159388f29f inherit pub_methods_classcomma_1_1_graph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the connectivity of the graph.  <a href="classcomma_1_1_graph.html#a72c40bec394188475ac30b159388f29f">More...</a><br /></td></tr>
<tr class="separator:a72c40bec394188475ac30b159388f29f inherit pub_methods_classcomma_1_1_graph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4d55d139f5812150abfa01e197f5e5 inherit pub_methods_classcomma_1_1_graph"><td class="memItemLeft" align="right" valign="top">CoMMAIntType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_graph.html#a4a4d55d139f5812150abfa01e197f5e5">compute_min_fc_compactness_inside_a_cc</a> (const std::unordered_set&lt; CoMMAIndexType &gt; &amp;s_fc) const</td></tr>
<tr class="memdesc:a4a4d55d139f5812150abfa01e197f5e5 inherit pub_methods_classcomma_1_1_graph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the minimum compactness of fine cells inside a coarse cell.  <a href="classcomma_1_1_graph.html#a4a4d55d139f5812150abfa01e197f5e5">More...</a><br /></td></tr>
<tr class="separator:a4a4d55d139f5812150abfa01e197f5e5 inherit pub_methods_classcomma_1_1_graph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ca107f24d5ba40ea695a23699eb1661 inherit pub_methods_classcomma_1_1_graph"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; CoMMAIndexType, CoMMAIntType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_graph.html#a5ca107f24d5ba40ea695a23699eb1661">compute_fc_compactness_inside_a_cc</a> (const std::unordered_set&lt; CoMMAIndexType &gt; &amp;s_fc) const</td></tr>
<tr class="memdesc:a5ca107f24d5ba40ea695a23699eb1661 inherit pub_methods_classcomma_1_1_graph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the dictionary of compactness of fine cells inside a coarse cell.  <a href="classcomma_1_1_graph.html#a5ca107f24d5ba40ea695a23699eb1661">More...</a><br /></td></tr>
<tr class="separator:a5ca107f24d5ba40ea695a23699eb1661 inherit pub_methods_classcomma_1_1_graph"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:aa791a6c06faf85eeab349adbb7010b7e"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; CoMMAIntType &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_dual___graph.html#aa791a6c06faf85eeab349adbb7010b7e">_n_bnd_faces</a></td></tr>
<tr class="memdesc:aa791a6c06faf85eeab349adbb7010b7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector telling how many boundary faces each cell has.  <a href="classcomma_1_1_dual___graph.html#aa791a6c06faf85eeab349adbb7010b7e">More...</a><br /></td></tr>
<tr class="separator:aa791a6c06faf85eeab349adbb7010b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af16576287d20ef656d4d7fa3479f0bed"><td class="memItemLeft" align="right" valign="top">const std::unordered_set&lt; CoMMAIndexType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_dual___graph.html#af16576287d20ef656d4d7fa3479f0bed">_s_anisotropic_compliant_cells</a></td></tr>
<tr class="memdesc:af16576287d20ef656d4d7fa3479f0bed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elements that are checked if they are anisotropic. If an element satisfies the condition for being anisotropic (typically, AR &gt; threshold) but it not in this set, it will not considered as anisotropic. We use a set to ensure uniqueness.  <a href="classcomma_1_1_dual___graph.html#af16576287d20ef656d4d7fa3479f0bed">More...</a><br /></td></tr>
<tr class="separator:af16576287d20ef656d4d7fa3479f0bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d4b45fcbf985e001a9137f38d8fd0d"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::vector&lt; CoMMAWeightType &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_dual___graph.html#a49d4b45fcbf985e001a9137f38d8fd0d">_centers</a></td></tr>
<tr class="memdesc:a49d4b45fcbf985e001a9137f38d8fd0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of cell centers.  <a href="classcomma_1_1_dual___graph.html#a49d4b45fcbf985e001a9137f38d8fd0d">More...</a><br /></td></tr>
<tr class="separator:a49d4b45fcbf985e001a9137f38d8fd0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbc7f2b85fe3771b78a1d485575ed4a3"><td class="memItemLeft" align="right" valign="top">std::function&lt; CoMMAWeightType(const CoMMAWeightType, const CoMMAWeightType)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_dual___graph.html#adbc7f2b85fe3771b78a1d485575ed4a3">_compute_AR</a></td></tr>
<tr class="memdesc:adbc7f2b85fe3771b78a1d485575ed4a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which computes the aspect-ratio from the minimum and maximum faces<br  />
 In 3D: <picture><source srcset="form_25_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ AR = sqrt(\frac{max_{surf}}{min_{surf}}) $" src="form_25.png"/></picture><br  />
 In 2D: <picture><source srcset="form_26_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ AR = \frac{max_{surf}}{min_{surf}} $" src="form_26.png"/></picture><br  />
 (Recall that in 2D a face is actually an edge)  <a href="classcomma_1_1_dual___graph.html#adbc7f2b85fe3771b78a1d485575ed4a3">More...</a><br /></td></tr>
<tr class="separator:adbc7f2b85fe3771b78a1d485575ed4a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classcomma_1_1_graph"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classcomma_1_1_graph')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classcomma_1_1_graph.html">comma::Graph&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;</a></td></tr>
<tr class="memitem:ad04e5b90c7fc132406dae34bb8f9fa49 inherit pub_attribs_classcomma_1_1_graph"><td class="memItemLeft" align="right" valign="top">CoMMAIndexType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_graph.html#ad04e5b90c7fc132406dae34bb8f9fa49">_number_of_cells</a></td></tr>
<tr class="memdesc:ad04e5b90c7fc132406dae34bb8f9fa49 inherit pub_attribs_classcomma_1_1_graph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of nodes in the <a class="el" href="classcomma_1_1_graph.html" title="An interface class responsible of storing the cell centered dual graph and of acting on it (it is an ...">Graph</a> (it corresponds to the number of cells in the subgraph or the dual graph.  <a href="classcomma_1_1_graph.html#ad04e5b90c7fc132406dae34bb8f9fa49">More...</a><br /></td></tr>
<tr class="separator:ad04e5b90c7fc132406dae34bb8f9fa49 inherit pub_attribs_classcomma_1_1_graph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec53729d369659cd15a85198a8d0595f inherit pub_attribs_classcomma_1_1_graph"><td class="memItemLeft" align="right" valign="top">std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_graph.html#aec53729d369659cd15a85198a8d0595f">_visited</a></td></tr>
<tr class="memdesc:aec53729d369659cd15a85198a8d0595f inherit pub_attribs_classcomma_1_1_graph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper vector for the DFS.  <a href="classcomma_1_1_graph.html#aec53729d369659cd15a85198a8d0595f">More...</a><br /></td></tr>
<tr class="separator:aec53729d369659cd15a85198a8d0595f inherit pub_attribs_classcomma_1_1_graph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a708321a816653163524e7f261bbe4cbe inherit pub_attribs_classcomma_1_1_graph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcomma_1_1_graph.html#ac24e8e9de0c15af027fe8d1ccd8304d4">ContainerIndexType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_graph.html#a708321a816653163524e7f261bbe4cbe">_m_CRS_Row_Ptr</a></td></tr>
<tr class="memdesc:a708321a816653163524e7f261bbe4cbe inherit pub_attribs_classcomma_1_1_graph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of row pointer of CRS representation.  <a href="classcomma_1_1_graph.html#a708321a816653163524e7f261bbe4cbe">More...</a><br /></td></tr>
<tr class="separator:a708321a816653163524e7f261bbe4cbe inherit pub_attribs_classcomma_1_1_graph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8d637d0718dbf470f51d8a7a07f3baa inherit pub_attribs_classcomma_1_1_graph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcomma_1_1_graph.html#ac24e8e9de0c15af027fe8d1ccd8304d4">ContainerIndexType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_graph.html#aa8d637d0718dbf470f51d8a7a07f3baa">_m_CRS_Col_Ind</a></td></tr>
<tr class="memdesc:aa8d637d0718dbf470f51d8a7a07f3baa inherit pub_attribs_classcomma_1_1_graph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of column index of CRS representation.  <a href="classcomma_1_1_graph.html#aa8d637d0718dbf470f51d8a7a07f3baa">More...</a><br /></td></tr>
<tr class="separator:aa8d637d0718dbf470f51d8a7a07f3baa inherit pub_attribs_classcomma_1_1_graph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07cb0d55e652d04e3e7c83c02efa757e inherit pub_attribs_classcomma_1_1_graph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcomma_1_1_graph.html#ab61394e58e9019e8d55320e3a2885115">ContainerWeightType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_graph.html#a07cb0d55e652d04e3e7c83c02efa757e">_m_CRS_Values</a></td></tr>
<tr class="memdesc:a07cb0d55e652d04e3e7c83c02efa757e inherit pub_attribs_classcomma_1_1_graph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of area weight of CRS representation.  <a href="classcomma_1_1_graph.html#a07cb0d55e652d04e3e7c83c02efa757e">More...</a><br /></td></tr>
<tr class="separator:a07cb0d55e652d04e3e7c83c02efa757e inherit pub_attribs_classcomma_1_1_graph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7ed39610dc52059d435b5c94f099f7b inherit pub_attribs_classcomma_1_1_graph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcomma_1_1_graph.html#ab61394e58e9019e8d55320e3a2885115">ContainerWeightType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_graph.html#ad7ed39610dc52059d435b5c94f099f7b">_volumes</a></td></tr>
<tr class="memdesc:ad7ed39610dc52059d435b5c94f099f7b inherit pub_attribs_classcomma_1_1_graph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of volumes.  <a href="classcomma_1_1_graph.html#ad7ed39610dc52059d435b5c94f099f7b">More...</a><br /></td></tr>
<tr class="separator:ad7ed39610dc52059d435b5c94f099f7b inherit pub_attribs_classcomma_1_1_graph"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename CoMMAIndexType, typename CoMMAWeightType, typename CoMMAIntType&gt;<br />
class comma::Dual_Graph&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;</div><p >A class implementing the CRS global graph representation of the global mesh. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CoMMAIndexType</td><td>the CoMMA index type for the global index of the mesh </td></tr>
    <tr><td class="paramname">CoMMAWeightType</td><td>the CoMMA weight type for the weights (volume or area) of the nodes or edges of the Mesh </td></tr>
    <tr><td class="paramname">CoMMAIntType</td><td>the CoMMA type for integers </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ab65d0e9268c98fd72916f2eb16ce4ab4" name="ab65d0e9268c98fd72916f2eb16ce4ab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab65d0e9268c98fd72916f2eb16ce4ab4">&#9670;&#160;</a></span>BaseClass</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomma_1_1_dual___graph.html">comma::Dual_Graph</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;::BaseClass =  <a class="el" href="classcomma_1_1_graph.html">Graph</a>&lt;CoMMAIndexType, CoMMAWeightType, CoMMAIntType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parent class. </p>

</div>
</div>
<a id="a9e4ca69b6d5fa9725246dfc96d85c112" name="a9e4ca69b6d5fa9725246dfc96d85c112"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e4ca69b6d5fa9725246dfc96d85c112">&#9670;&#160;</a></span>CoMMAPairType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomma_1_1_dual___graph.html">comma::Dual_Graph</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;::CoMMAPairType =  std::pair&lt;CoMMAIndexType, CoMMAWeightType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of pair. </p>

</div>
</div>
<a id="ac83b5f3409ccd78654bc747f43e2d6d6" name="ac83b5f3409ccd78654bc747f43e2d6d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac83b5f3409ccd78654bc747f43e2d6d6">&#9670;&#160;</a></span>CoMMASetOfPairType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomma_1_1_dual___graph.html">comma::Dual_Graph</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;::CoMMASetOfPairType =  std::set&lt;<a class="el" href="classcomma_1_1_dual___graph.html#a9e4ca69b6d5fa9725246dfc96d85c112">CoMMAPairType</a>, <a class="el" href="structcomma_1_1_custom_pair_greater_functor.html">CustomPairGreaterFunctor</a>&lt;<a class="el" href="classcomma_1_1_dual___graph.html#a9e4ca69b6d5fa9725246dfc96d85c112">CoMMAPairType</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of set of pairs. </p>

</div>
</div>
<a id="ac24e8e9de0c15af027fe8d1ccd8304d4" name="ac24e8e9de0c15af027fe8d1ccd8304d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac24e8e9de0c15af027fe8d1ccd8304d4">&#9670;&#160;</a></span>ContainerIndexType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomma_1_1_graph.html">comma::Graph</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;::ContainerIndexType =  std::vector&lt;CoMMAIndexType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for containers of indices. </p>

</div>
</div>
<a id="ab61394e58e9019e8d55320e3a2885115" name="ab61394e58e9019e8d55320e3a2885115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab61394e58e9019e8d55320e3a2885115">&#9670;&#160;</a></span>ContainerWeightType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomma_1_1_graph.html">comma::Graph</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;::ContainerWeightType =  std::vector&lt;CoMMAWeightType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for containers of weights. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a62db97821210fa0ffa99d3396eecdaae" name="a62db97821210fa0ffa99d3396eecdaae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62db97821210fa0ffa99d3396eecdaae">&#9670;&#160;</a></span>Dual_Graph()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcomma_1_1_dual___graph.html">comma::Dual_Graph</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;::Dual_Graph </td>
          <td>(</td>
          <td class="paramtype">const CoMMAIndexType &amp;&#160;</td>
          <td class="paramname"><em>nb_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcomma_1_1_dual___graph.html#ac24e8e9de0c15af027fe8d1ccd8304d4">ContainerIndexType</a> &amp;&#160;</td>
          <td class="paramname"><em>m_crs_row_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcomma_1_1_dual___graph.html#ac24e8e9de0c15af027fe8d1ccd8304d4">ContainerIndexType</a> &amp;&#160;</td>
          <td class="paramname"><em>m_crs_col_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcomma_1_1_dual___graph.html#ab61394e58e9019e8d55320e3a2885115">ContainerWeightType</a> &amp;&#160;</td>
          <td class="paramname"><em>m_crs_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcomma_1_1_dual___graph.html#ab61394e58e9019e8d55320e3a2885115">ContainerWeightType</a> &amp;&#160;</td>
          <td class="paramname"><em>volumes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; CoMMAWeightType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>centers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; CoMMAIntType &gt; &amp;&#160;</td>
          <td class="paramname"><em>n_bnd_faces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CoMMAIntType&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcomma_1_1_dual___graph.html#ac24e8e9de0c15af027fe8d1ccd8304d4">ContainerIndexType</a> &amp;&#160;</td>
          <td class="paramname"><em>anisotropic_compliant_fc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor of the class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nb_c</td><td>Number of cells </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m_crs_row_ptr</td><td>The row pointer of the CRS representation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m_crs_col_ind</td><td>The column index of the CRS representation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m_crs_values</td><td>The weight of the CRS representation (in CoMMA case will be the area of the faces that in the graph representation are the edges between two nodes represented by the cell centers. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">volumes</td><td>The volumes of the cells </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">centers</td><td>Cell centers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_bnd_faces</td><td>Vector telling how many boundary faces each cell has </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dimension</td><td>Dimensionality of the problem, 2- or 3D </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">anisotropic_compliant_fc</td><td>Set of compliant fc cells (in the most of the case all) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad2ece10214db2a38f54b4c2e4ab4451f" name="ad2ece10214db2a38f54b4c2e4ab4451f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2ece10214db2a38f54b4c2e4ab4451f">&#9670;&#160;</a></span>~Dual_Graph()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcomma_1_1_dual___graph.html">comma::Dual_Graph</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;::~<a class="el" href="classcomma_1_1_dual___graph.html">Dual_Graph</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor of the class. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a20485b4e0bddf0fd2e6fe38b5aa7582b" name="a20485b4e0bddf0fd2e6fe38b5aa7582b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20485b4e0bddf0fd2e6fe38b5aa7582b">&#9670;&#160;</a></span>compute_neighbourhood_of_cc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomma_1_1_dual___graph.html">comma::Dual_Graph</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;::compute_neighbourhood_of_cc </td>
          <td>(</td>
          <td class="paramtype">const std::unordered_set&lt; CoMMAIndexType &gt; &amp;&#160;</td>
          <td class="paramname"><em>s_seeds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoMMAIntType &amp;&#160;</td>
          <td class="paramname"><em>nb_of_order_of_neighbourhood</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_map&lt; CoMMAIndexType, CoMMAIntType &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_n_of_seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CoMMAIntType&#160;</td>
          <td class="paramname"><em>max_card</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>is_fc_agglomerated_tmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the dictionary of compactness of fine cells inside a coarse cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s_seeds</td><td>Set of seeds for which the neighbourhood must be computed. Generally they are the fine cells composing the coarse cell for which we are trying to compute the neighbourhood. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nb_of_order_of_neighbourhood</td><td>order Of the neighbourhood at which we want to extend the dictionary </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_n_of_seed</td><td>Dictionary of the neighbourhood given as an output. The key of the associative structure is the index of the fine cell, the value is the order of the distance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_card</td><td>Maximum cardinality </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_fc_agglomerated_tmp</td><td>Vector reporting the already agglomerated cell, useful in the algorithm </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af4e2cd99bd2e6035febcd49ff460ce3e" name="af4e2cd99bd2e6035febcd49ff460ce3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4e2cd99bd2e6035febcd49ff460ce3e">&#9670;&#160;</a></span>estimated_boundary_weight()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CoMMAWeightType <a class="el" href="classcomma_1_1_dual___graph.html">comma::Dual_Graph</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;::estimated_boundary_weight </td>
          <td>(</td>
          <td class="paramtype">const CoMMAIndexType&#160;</td>
          <td class="paramname"><em>idx_c</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximate the value of a boundary face using the known internal faces. It uses a (geometric) average, so the result is correct only if the cell is a regular polygon. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx_c</td><td>Index of the cell </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An approximation of the surface of a boundary face </dd></dl>

</div>
</div>
<a id="a5bed2815c618f5670469a6cb38863f0e" name="a5bed2815c618f5670469a6cb38863f0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bed2815c618f5670469a6cb38863f0e">&#9670;&#160;</a></span>estimated_total_weight()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CoMMAWeightType <a class="el" href="classcomma_1_1_dual___graph.html">comma::Dual_Graph</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;::estimated_total_weight </td>
          <td>(</td>
          <td class="paramtype">const CoMMAIndexType&#160;</td>
          <td class="paramname"><em>idx_c</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sum of wall the weights (faces) of a cell. Since there is no knowledge about boundary faces, the result is correct only if internal cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx_c</td><td>Index of the cell </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total weight </dd></dl>

</div>
</div>
<a id="a020ecb0b3f410b468bbb8e57878bf9aa" name="a020ecb0b3f410b468bbb8e57878bf9aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a020ecb0b3f410b468bbb8e57878bf9aa">&#9670;&#160;</a></span>get_n_boundary_faces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CoMMAIntType <a class="el" href="classcomma_1_1_dual___graph.html">comma::Dual_Graph</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;::get_n_boundary_faces </td>
          <td>(</td>
          <td class="paramtype">const CoMMAIndexType&#160;</td>
          <td class="paramname"><em>idx_c</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return how many boundary faces a certain cell has. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx_c</td><td>Index of the cell </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of boundary faces </dd></dl>

</div>
</div>
<a id="a03162eab93fc7ace92992ebea53db274" name="a03162eab93fc7ace92992ebea53db274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03162eab93fc7ace92992ebea53db274">&#9670;&#160;</a></span>get_nb_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CoMMAIntType <a class="el" href="classcomma_1_1_dual___graph.html">comma::Dual_Graph</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;::get_nb_cells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter that returns the number of cells. </p>
<dl class="section return"><dt>Returns</dt><dd>number of cells </dd></dl>

</div>
</div>
<a id="a7e3f45ecd852a941dc39064f7454efb3" name="a7e3f45ecd852a941dc39064f7454efb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e3f45ecd852a941dc39064f7454efb3">&#9670;&#160;</a></span>get_neighbourhood_of_cc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_set&lt; CoMMAIndexType &gt; <a class="el" href="classcomma_1_1_dual___graph.html">comma::Dual_Graph</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;::get_neighbourhood_of_cc </td>
          <td>(</td>
          <td class="paramtype">const std::unordered_set&lt; CoMMAIndexType &gt; &amp;&#160;</td>
          <td class="paramname"><em>s_seeds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>is_fc_agglomerated_tmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the fine cells neighbours of a coarse cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s_seeds</td><td>Set of seeds for which the neighbourhood should be computed. Generally they are the fine cells composing the coarse cell for which we are trying to compute the neighbourhood. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_fc_agglomerated_tmp</td><td>Vector reporting the already agglomerated cell, useful in the algorithm </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The set of neighbours </dd></dl>

</div>
</div>
<a id="a3e13a84eed233df574dc50a0b7d3adf5" name="a3e13a84eed233df574dc50a0b7d3adf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e13a84eed233df574dc50a0b7d3adf5">&#9670;&#160;</a></span>get_total_n_faces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CoMMAIntType <a class="el" href="classcomma_1_1_dual___graph.html">comma::Dual_Graph</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;::get_total_n_faces </td>
          <td>(</td>
          <td class="paramtype">const CoMMAIndexType&#160;</td>
          <td class="paramname"><em>idx_c</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return total number of faces, that is, number of neighbours plus number of boundaries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx_c</td><td>Index of the cell </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of faces </dd></dl>

</div>
</div>
<a id="a243466aae3bc5b1a7c1f259dc398ce67" name="a243466aae3bc5b1a7c1f259dc398ce67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a243466aae3bc5b1a7c1f259dc398ce67">&#9670;&#160;</a></span>is_on_boundary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcomma_1_1_dual___graph.html">comma::Dual_Graph</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;::is_on_boundary </td>
          <td>(</td>
          <td class="paramtype">const CoMMAIndexType&#160;</td>
          <td class="paramname"><em>idx_c</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether a cell is on the boundary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx_c</td><td>Index of the cell </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether a cell is on the boundary </dd></dl>

</div>
</div>
<a id="ae54c9474438da03527cc8eab80362cf3" name="ae54c9474438da03527cc8eab80362cf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae54c9474438da03527cc8eab80362cf3">&#9670;&#160;</a></span>tag_anisotropic_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomma_1_1_dual___graph.html">comma::Dual_Graph</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;::tag_anisotropic_cells </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcomma_1_1_dual___graph.html#ab61394e58e9019e8d55320e3a2885115">ContainerWeightType</a> &amp;&#160;</td>
          <td class="paramname"><em>max_weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>is_anisotropic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::deque&lt; CoMMAIndexType &gt; &amp;&#160;</td>
          <td class="paramname"><em>aniso_seeds_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CoMMAWeightType&#160;</td>
          <td class="paramname"><em>threshold_anisotropy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcomma_1_1_dual___graph.html#ab61394e58e9019e8d55320e3a2885115">ContainerWeightType</a> &amp;&#160;</td>
          <td class="paramname"><em>priority_weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CoMMAIndexType&#160;</td>
          <td class="paramname"><em>preserving</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tag cells as anisotropic if their aspect-ratio is over a given threshold and order them according to given priority. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">max_weights</td><td>Array of the maximum weight: the biggest area of the faces composing the given fine cell </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_anisotropic</td><td>Vector of length equal to the total number of cell telling whether a cell is anisotropic </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">aniso_seeds_pool</td><td>Container containing the anisotropic cells in the order they should be considered when computing the lines </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">threshold_anisotropy</td><td>Value of the aspect ratio above which a cell is considered anisotropic. If negative, all compliant cells are considered as anisotropic </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">priority_weights</td><td>Weights used to set the order telling where to start agglomerating. The higher the weight, the higher the priority </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">preserving</td><td>if 0 does not hit only the BL prism to preserve the boundary layer otherwise 2 for 2D or 3 for the 3D to preserve the BL only in the anisotropic agglomeration </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a49d4b45fcbf985e001a9137f38d8fd0d" name="a49d4b45fcbf985e001a9137f38d8fd0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49d4b45fcbf985e001a9137f38d8fd0d">&#9670;&#160;</a></span>_centers</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::vector&lt;CoMMAWeightType&gt; &gt;&amp; <a class="el" href="classcomma_1_1_dual___graph.html">comma::Dual_Graph</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;::_centers</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vector of cell centers. </p>

</div>
</div>
<a id="adbc7f2b85fe3771b78a1d485575ed4a3" name="adbc7f2b85fe3771b78a1d485575ed4a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbc7f2b85fe3771b78a1d485575ed4a3">&#9670;&#160;</a></span>_compute_AR</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;CoMMAWeightType(const CoMMAWeightType, const CoMMAWeightType)&gt; <a class="el" href="classcomma_1_1_dual___graph.html">comma::Dual_Graph</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;::_compute_AR</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function which computes the aspect-ratio from the minimum and maximum faces<br  />
 In 3D: <picture><source srcset="form_25_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ AR = sqrt(\frac{max_{surf}}{min_{surf}}) $" src="form_25.png"/></picture><br  />
 In 2D: <picture><source srcset="form_26_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ AR = \frac{max_{surf}}{min_{surf}} $" src="form_26.png"/></picture><br  />
 (Recall that in 2D a face is actually an edge) </p>

</div>
</div>
<a id="aa791a6c06faf85eeab349adbb7010b7e" name="aa791a6c06faf85eeab349adbb7010b7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa791a6c06faf85eeab349adbb7010b7e">&#9670;&#160;</a></span>_n_bnd_faces</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;CoMMAIntType&gt;&amp; <a class="el" href="classcomma_1_1_dual___graph.html">comma::Dual_Graph</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;::_n_bnd_faces</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vector telling how many boundary faces each cell has. </p>

</div>
</div>
<a id="af16576287d20ef656d4d7fa3479f0bed" name="af16576287d20ef656d4d7fa3479f0bed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af16576287d20ef656d4d7fa3479f0bed">&#9670;&#160;</a></span>_s_anisotropic_compliant_cells</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::unordered_set&lt;CoMMAIndexType&gt; <a class="el" href="classcomma_1_1_dual___graph.html">comma::Dual_Graph</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;::_s_anisotropic_compliant_cells</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Elements that are checked if they are anisotropic. If an element satisfies the condition for being anisotropic (typically, AR &gt; threshold) but it not in this set, it will not considered as anisotropic. We use a set to ensure uniqueness. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/CoMMA/<a class="el" href="_dual___graph_8h_source.html">Dual_Graph.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacecomma.html">comma</a></li><li class="navelem"><a class="el" href="classcomma_1_1_dual___graph.html">Dual_Graph</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
