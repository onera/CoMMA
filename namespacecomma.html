<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CoMMA: comma Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo-CoMMA_70x70.jpg"/></td>
  <td id="projectalign">
   <div id="projectname">CoMMA<span id="projectnumber">&#160;1.3.2</span>
   </div>
   <div id="projectbrief">A geometric agglomerator for unstructured meshes</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespacecomma.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">comma Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_agglomeration_args.html">AgglomerationArgs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient class holding arguments for the parametrization of the agglomeration algorithm.  <a href="classcomma_1_1_agglomeration_args.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_agglomerator.html">Agglomerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class responsible to do the interface between the different kinds of agglomerator.  <a href="classcomma_1_1_agglomerator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_agglomerator___anisotropic.html">Agglomerator_Anisotropic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcomma_1_1_agglomerator___anisotropic.html" title="Agglomerator_Anisotropic class is a child class of the Agglomerator class that specializes the implem...">Agglomerator_Anisotropic</a> class is a child class of the <a class="el" href="classcomma_1_1_agglomerator.html" title="A class responsible to do the interface between the different kinds of agglomerator.">Agglomerator</a> class that specializes the implementation to the case of Anisotropic agglomeration.  <a href="classcomma_1_1_agglomerator___anisotropic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_agglomerator___biconnected.html">Agglomerator_Biconnected</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Child class of <a class="el" href="classcomma_1_1_agglomerator___isotropic.html" title="Agglomerator_Isotropic class is a child class of the Agglomerator class that specializes the implemen...">Agglomerator_Isotropic</a> where is implemented a specific biconnected algorithm for the agglomeration. We call it biconnected case, but it is the greedy algorithm in reality.  <a href="classcomma_1_1_agglomerator___biconnected.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_agglomerator___isotropic.html">Agglomerator_Isotropic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcomma_1_1_agglomerator___isotropic.html" title="Agglomerator_Isotropic class is a child class of the Agglomerator class that specializes the implemen...">Agglomerator_Isotropic</a> class is a child class of the <a class="el" href="classcomma_1_1_agglomerator.html" title="A class responsible to do the interface between the different kinds of agglomerator.">Agglomerator</a> class that specializes the implementation to the case of Isotropic agglomeration.  <a href="classcomma_1_1_agglomerator___isotropic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_agglomerator___iterative.html">Agglomerator_Iterative</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Child class of <a class="el" href="classcomma_1_1_agglomerator___isotropic.html" title="Agglomerator_Isotropic class is a child class of the Agglomerator class that specializes the implemen...">Agglomerator_Isotropic</a> which implements a specialized iterative algorithm for the search of fine cells.  <a href="classcomma_1_1_agglomerator___iterative.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_anisotropic_args.html">AnisotropicArgs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient class holding arguments for the parametrization of the anisotropic agglomeration algorithm.  <a href="classcomma_1_1_anisotropic_args.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_a_r_computer.html">ARComputer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to a functor, the key point is the method that computes the AR and update the features of a cell. Here, AR is used lightly, and might be any quantity which should be minimized in the coarsening process. This is an abstract class.  <a href="classcomma_1_1_a_r_computer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_a_r_diameter.html">ARDiameter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcomma_1_1_a_r_computer.html" title="Similar to a functor, the key point is the method that computes the AR and update the features of a c...">ARComputer</a>. Here, AR is the approximated diameter.  <a href="classcomma_1_1_a_r_diameter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_a_r_diam_over_min_edge.html">ARDiamOverMinEdge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcomma_1_1_a_r_computer.html" title="Similar to a functor, the key point is the method that computes the AR and update the features of a c...">ARComputer</a>. Here, AR is the ratio of the diameter over the smallest edge.  <a href="classcomma_1_1_a_r_diam_over_min_edge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_a_r_diam_over_radius.html">ARDiamOverRadius</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcomma_1_1_a_r_computer.html" title="Similar to a functor, the key point is the method that computes the AR and update the features of a c...">ARComputer</a>. Here, AR is the ratio of the diameter over the estimated one (typically, in 2D, the squared root of the surface). It is the definition used in CoMMA from 1.1 up to 1.3.2.  <a href="classcomma_1_1_a_r_diam_over_radius.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_a_r_external_weight_over_radius.html">ARExternalWeightOverRadius</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcomma_1_1_a_r_computer.html" title="Similar to a functor, the key point is the method that computes the AR and update the features of a c...">ARComputer</a>. Here, AR is the ratio of the external weights over the measure. With <code>dim</code> equal to 2, it is roughly equivalent to the ration of the perimeter and the surface of the cell. Moreover, with <code>dim</code> = 2, it is equivalent to the definition used by CoMMA up to version 1.0. For an algebraic version (where no concern is given to adimensionalize the AR), use <code>dim</code> equal to 1.  <a href="classcomma_1_1_a_r_external_weight_over_radius.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_a_r_external_weights.html">ARExternalWeights</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcomma_1_1_a_r_computer.html" title="Similar to a functor, the key point is the method that computes the AR and update the features of a c...">ARComputer</a>. Here, AR is the total external weights (that is, from a geometric point of view, the perimeter). Looking for the minimum leads in graph terms to a min-cut.  <a href="classcomma_1_1_a_r_external_weights.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_a_r_max_bary_distance_over_radius.html">ARMaxBaryDistanceOverRadius</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcomma_1_1_a_r_computer.html" title="Similar to a functor, the key point is the method that computes the AR and update the features of a c...">ARComputer</a>. Here, AR is the ratio of the maximum over minimum distance of the cell centers from the barycenter (computed as weighted average of centers). If a cell is totally internal, it won't be included in the computations.  <a href="classcomma_1_1_a_r_max_bary_distance_over_radius.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_a_r_max_over_min_bary_distance.html">ARMaxOverMinBaryDistance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcomma_1_1_a_r_computer.html" title="Similar to a functor, the key point is the method that computes the AR and update the features of a c...">ARComputer</a>. Here, AR is the ratio of the maximum over minimum distance of the cell centers from the barycenter (computed as weighted average of centers). If a cell is totally internal, it won't be included in the computations.  <a href="classcomma_1_1_a_r_max_over_min_bary_distance.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_a_r_over_internal_weights.html">AROverInternalWeights</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcomma_1_1_a_r_computer.html" title="Similar to a functor, the key point is the method that computes the AR and update the features of a c...">ARComputer</a>. Here, AR is one over the internal weights (looking for the minimum leads to the maximization of the internal weights).  <a href="classcomma_1_1_a_r_over_internal_weights.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_a_r_over_measure.html">AROverMeasure</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcomma_1_1_a_r_computer.html" title="Similar to a functor, the key point is the method that computes the AR and update the features of a c...">ARComputer</a>. Here, AR is the reciprocal of the measure, hence the optimal solution should be the one with the max measure.  <a href="classcomma_1_1_a_r_over_measure.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_bimap.html">Bimap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An easy and straight forward implementation of a <a class="el" href="classcomma_1_1_bimap.html" title="An easy and straight forward implementation of a Bimap.">Bimap</a>.  <a href="classcomma_1_1_bimap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_cell_features.html">CellFeatures</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient class containing salient features of a cell. According to to the chosen AR computation (see <a class="el" href="classcomma_1_1_a_r_computer.html" title="Similar to a functor, the key point is the method that computes the AR and update the features of a c...">ARComputer</a>), some features may be outdated.  <a href="classcomma_1_1_cell_features.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_coarse___cell.html">Coarse_Cell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class describing a coarse cell.  <a href="classcomma_1_1_coarse___cell.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_coarse___cell___container.html">Coarse_Cell_Container</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class implementing a custom container where the coarse cells are stored.  <a href="classcomma_1_1_coarse___cell___container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_coarse___cell___subgraph.html">Coarse_Cell_Subgraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class describing a coarse cell with a full description, that is, it also holds a subgraph describing how the fine cells are connected inside the coarse one.  <a href="classcomma_1_1_coarse___cell___subgraph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcomma_1_1_custom_pair_greater_functor.html">CustomPairGreaterFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor for pairs implementing a custom 'greater than'. It relies on the 'greater than' operator for the second elements and 'less than' for the first ones.  <a href="structcomma_1_1_custom_pair_greater_functor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcomma_1_1_custom_pair_less_functor.html">CustomPairLessFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor for pairs implementing a custom 'less than'. It relies on the 'less than' operator for the second elements and 'greater than' for the first ones.  <a href="structcomma_1_1_custom_pair_less_functor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_dual___graph.html">Dual_Graph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class implementing the CRS global graph representation of the global mesh.  <a href="classcomma_1_1_dual___graph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_graph.html">Graph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An interface class responsible of storing the cell centered dual graph and of acting on it (it is an interface for the global <a class="el" href="classcomma_1_1_dual___graph.html" title="A class implementing the CRS global graph representation of the global mesh.">Dual_Graph</a> and the <a class="el" href="classcomma_1_1_subgraph.html" title="A class implementing the CRS subgraph representation. It is used in the framework of CoMMA for the im...">Subgraph</a>)  <a href="classcomma_1_1_graph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_graph_args.html">GraphArgs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient class holding arguments defining the graph.  <a href="classcomma_1_1_graph_args.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_neighbourhood.html">Neighbourhood</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing the neighbourhood of a given cell in the graph. Mind that no information about the element being already agglomerated or not is known here.  <a href="classcomma_1_1_neighbourhood.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_neighbourhood___extended.html">Neighbourhood_Extended</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing the neighbourhood of a given cell in the graph. In this derived class the neighbourhood is extended, meaning that all the neighbours seen so far are candidates.  <a href="classcomma_1_1_neighbourhood___extended.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_neighbourhood___pure___front.html">Neighbourhood_Pure_Front</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing the neighbourhood of a given cell in the graph. In this derived class, the neighbourhood is 'pure front-advancing', meaning that the next candidates are only the direct neighbours of the last added cell.  <a href="classcomma_1_1_neighbourhood___pure___front.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_neighbourhood_creator.html">NeighbourhoodCreator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pure abstract class for a creator of <a class="el" href="classcomma_1_1_neighbourhood.html" title="Class representing the neighbourhood of a given cell in the graph. Mind that no information about the...">Neighbourhood</a> objects. It can create from scratch or by copy.  <a href="classcomma_1_1_neighbourhood_creator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_neighbourhood_extended_creator.html">NeighbourhoodExtendedCreator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creator of <a class="el" href="classcomma_1_1_neighbourhood___extended.html" title="Class representing the neighbourhood of a given cell in the graph. In this derived class the neighbou...">Neighbourhood_Extended</a> objects. It can create from scratch or by copy.  <a href="classcomma_1_1_neighbourhood_extended_creator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_neighbourhood_pure_front_creator.html">NeighbourhoodPureFrontCreator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creator of <a class="el" href="classcomma_1_1_neighbourhood___extended.html" title="Class representing the neighbourhood of a given cell in the graph. In this derived class the neighbou...">Neighbourhood_Extended</a> objects. It can create from scratch or by copy.  <a href="classcomma_1_1_neighbourhood_pure_front_creator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_node.html">Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcomma_1_1_node.html" title="Node data structure that represent a node of the tree.">Node</a> data structure that represent a node of the tree.  <a href="classcomma_1_1_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_pair_find_first_based_functor.html">PairFindFirstBasedFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor implementing an operator telling if a given value if the first one of pair.  <a href="classcomma_1_1_pair_find_first_based_functor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcomma_1_1_pair_second_based_less_functor.html">PairSecondBasedLessFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor for pairs implementing a less operator based only on the second element of the pair.  <a href="structcomma_1_1_pair_second_based_less_functor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_priority___pair.html">Priority_Pair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around the STL pair with custom 'less than' operator: as in the standard case, first we compare the first elements, then the second ones; however it relies on the 'greater than' on the first elements, e.g., (4,X) &lt; (3,Y), whereas standard rules apply to second elements, e.g., (4,3) &lt; (4,4).  <a href="classcomma_1_1_priority___pair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_queue.html">Queue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template class implementing a custom queue data structure.  <a href="classcomma_1_1_queue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_seeds___pool.html">Seeds_Pool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing the pool of all the seeds for creating a coarse cell.  <a href="classcomma_1_1_seeds___pool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_seeds___pool___boundary___priority.html">Seeds_Pool_Boundary_Priority</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing the pool of all the seeds for creating a coarse cell. This derived class gives higher priority to cells that are on the border.  <a href="classcomma_1_1_seeds___pool___boundary___priority.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_seeds___pool___neighbourhood___priority.html">Seeds_Pool_Neighbourhood_Priority</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing the pool of all the seeds for creating a coarse cell. This derived class gives higher priority to cells that are neighbours of already existing coarse cells.  <a href="classcomma_1_1_seeds___pool___neighbourhood___priority.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcomma_1_1_s_p_full_initializator.html">SPFullInitializator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor performing the full initialization of a seeds pool.  <a href="structcomma_1_1_s_p_full_initializator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcomma_1_1_s_p_initializator.html">SPInitializator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor performing the initialization of a seeds pool.  <a href="structcomma_1_1_s_p_initializator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcomma_1_1_s_p_one_point_initializator.html">SPOnePointInitializator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor performing the one-point initialization of a seeds pool.  <a href="structcomma_1_1_s_p_one_point_initializator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_subgraph.html">Subgraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class implementing the CRS subgraph representation. It is used in the framework of CoMMA for the implementation of the CSR representation of the coarse cells.  <a href="classcomma_1_1_subgraph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_tree.html">Tree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcomma_1_1_tree.html" title="Tree structure that represent a coarse cell, the fine cell and the neighbours to them.">Tree</a> structure that represent a coarse cell, the fine cell and the neighbours to them.  <a href="classcomma_1_1_tree.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a6676cd5a4d3dbf9141f8c7bc87617be8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecomma.html#a6676cd5a4d3dbf9141f8c7bc87617be8">CoMMACellT</a> : CoMMAIntT { <br />
&#160;&#160;<a class="el" href="namespacecomma.html#a6676cd5a4d3dbf9141f8c7bc87617be8ada6f7a085b1f7f2125ce30f5e02db53c">INTERIOR</a> = 0
, <a class="el" href="namespacecomma.html#a6676cd5a4d3dbf9141f8c7bc87617be8a4f18a70072d52370244908b93cf13e85">VALLEY</a> = 1
, <a class="el" href="namespacecomma.html#a6676cd5a4d3dbf9141f8c7bc87617be8aaa4cdfbb2d1efc15da1728bbc125e9f1">RIDGE</a> = 2
, <a class="el" href="namespacecomma.html#a6676cd5a4d3dbf9141f8c7bc87617be8a39ad49623cc576b66fc391bd2bc1c7cf">CORNER</a> = 3
, <br />
&#160;&#160;<a class="el" href="namespacecomma.html#a6676cd5a4d3dbf9141f8c7bc87617be8ac5e925f6e54a010df01d51f9b4e6f981">EXTREME</a> = 4
, <a class="el" href="namespacecomma.html#a6676cd5a4d3dbf9141f8c7bc87617be8a0309283de9cefb87968e32825c3418ec">N_CELL_TYPES</a> = 4
<br />
 }</td></tr>
<tr class="memdesc:a6676cd5a4d3dbf9141f8c7bc87617be8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of an element according to its boundary faces / edges The terms come from the NIA paper: Nishikawa, Diskin, Thomas...  <a href="namespacecomma.html#a6676cd5a4d3dbf9141f8c7bc87617be8">More...</a><br /></td></tr>
<tr class="separator:a6676cd5a4d3dbf9141f8c7bc87617be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a705b45ec112a3ac1bf59f760f0f4d022"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecomma.html#a705b45ec112a3ac1bf59f760f0f4d022">CoMMANeighbourhoodT</a> : CoMMAIntT { <a class="el" href="namespacecomma.html#a705b45ec112a3ac1bf59f760f0f4d022a5b91bee96d92adb448b6529d2ea8289d">EXTENDED</a> = 0
, <a class="el" href="namespacecomma.html#a705b45ec112a3ac1bf59f760f0f4d022a681aa75b2dff7410008df1396b15fe35">PURE_FRONT</a> = 1
 }</td></tr>
<tr class="memdesc:a705b45ec112a3ac1bf59f760f0f4d022"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of neighbourhood (of a coarse cell) considered when agglomerating.  <a href="namespacecomma.html#a705b45ec112a3ac1bf59f760f0f4d022">More...</a><br /></td></tr>
<tr class="separator:a705b45ec112a3ac1bf59f760f0f4d022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c8213401033616d834d48d77bf359a4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecomma.html#a8c8213401033616d834d48d77bf359a4">CoMMASeedsPoolT</a> : CoMMAIntT { <a class="el" href="namespacecomma.html#a8c8213401033616d834d48d77bf359a4a7340b7195c9071cd34c7d9a633a3d857">BOUNDARY_PRIORITY</a> = 0
, <a class="el" href="namespacecomma.html#a8c8213401033616d834d48d77bf359a4ae3fbc583bddef8540a06125ed1e7dc79">NEIGHBOURHOOD_PRIORITY</a> = 1
, <a class="el" href="namespacecomma.html#a8c8213401033616d834d48d77bf359a4a29ddaed9cc8cda952d02296b79010787">BOUNDARY_PRIORITY_ONE_POINT_INIT</a> = 10
, <a class="el" href="namespacecomma.html#a8c8213401033616d834d48d77bf359a4a8c23e18158e720cbd348f98e50376a5d">NEIGHBOURHOOD_PRIORITY_ONE_POINT_INIT</a> = 11
 }</td></tr>
<tr class="memdesc:a8c8213401033616d834d48d77bf359a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of seeds pool ordering.  <a href="namespacecomma.html#a8c8213401033616d834d48d77bf359a4">More...</a><br /></td></tr>
<tr class="separator:a8c8213401033616d834d48d77bf359a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1202bb0cca3487ffda41fee403ac02e8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecomma.html#a1202bb0cca3487ffda41fee403ac02e8">CoMMAAspectRatioT</a> : CoMMAIntT { <br />
&#160;&#160;<a class="el" href="namespacecomma.html#a1202bb0cca3487ffda41fee403ac02e8aa351872cd7850f5acd1c0f7d15791ac3">DIAMETER_OVER_RADIUS</a> = 0
, <a class="el" href="namespacecomma.html#a1202bb0cca3487ffda41fee403ac02e8ad95bf49ebe2c8dffb7925f1f6c8ea501">DIAMETER_OVER_MIN_EDGE</a>
, <a class="el" href="namespacecomma.html#a1202bb0cca3487ffda41fee403ac02e8aed2ee02285e0e6f65604cec18a72906a">DIAMETER</a>
, <a class="el" href="namespacecomma.html#a1202bb0cca3487ffda41fee403ac02e8a24e459b8a19def0f2202bd0007fc5f51">ONE_OVER_MEASURE</a>
, <br />
&#160;&#160;<a class="el" href="namespacecomma.html#a1202bb0cca3487ffda41fee403ac02e8a338fbd50e6953c9f8d4bed80203ab293">ONE_OVER_INTERNAL_WEIGHTS</a>
, <a class="el" href="namespacecomma.html#a1202bb0cca3487ffda41fee403ac02e8af88e6862b1602f233d2d495a9b1d1e98">PERIMETER_OVER_RADIUS</a>
, <a class="el" href="namespacecomma.html#a1202bb0cca3487ffda41fee403ac02e8a77ecfee8b6ce57670d02fceec49c89d5">EXTERNAL_WEIGHTS</a>
, <a class="el" href="namespacecomma.html#a1202bb0cca3487ffda41fee403ac02e8a8e8c23ebd7ed4f6183e3b0d87986dfed">MAX_BARY_DIST_OVER_RADIUS</a>
, <br />
&#160;&#160;<a class="el" href="namespacecomma.html#a1202bb0cca3487ffda41fee403ac02e8adea3279d5aefb79b3587092acda0310c">MAX_OVER_MIN_BARY_DIST</a>
, <a class="el" href="namespacecomma.html#a1202bb0cca3487ffda41fee403ac02e8a40c0eaf07c674d996bc2044ceccce8ce">ALGEBRAIC_PERIMETER_OVER_MEASURE</a>
<br />
 }</td></tr>
<tr class="memdesc:a1202bb0cca3487ffda41fee403ac02e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of aspect-ratio. Notation:  <a href="namespacecomma.html#a1202bb0cca3487ffda41fee403ac02e8">More...</a><br /></td></tr>
<tr class="separator:a1202bb0cca3487ffda41fee403ac02e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8c3495d8f36ab061528f00181514a64a"><td class="memTemplParams" colspan="2">template&lt;typename IndexT , typename RealT , typename IntT , int dim&gt; </td></tr>
<tr class="memitem:a8c3495d8f36ab061528f00181514a64a"><td class="memTemplItemLeft" align="right" valign="top">RealT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomma.html#a8c3495d8f36ab061528f00181514a64a">compute_AR_max_ov_radius</a> (const <a class="el" href="classcomma_1_1_cell_features.html">CellFeatures</a>&lt; IndexT, RealT, IntT &gt; &amp;feat)</td></tr>
<tr class="memdesc:a8c3495d8f36ab061528f00181514a64a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the features of a cell, compute its aspect-ratio. This uses the diameter and the measure.<br  />
 In 3D: <picture><source srcset="form_0_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ AR = \frac{diam_{CC}}{\sqrt{vol_{CC}}} $" src="form_0.png"/></picture> <br  />
 In 2D: <picture><source srcset="form_1_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ AR = \frac{diam_{CC}}{\sqrt[3]{vol_{CC}}} $" src="form_1.png"/></picture> (Recall that in 2D the volume is the surface) <br  />
 Generally, for dimension <picture><source srcset="form_2_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ d &gt;=2 $" src="form_2.png"/></picture>: <picture><source srcset="form_3_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ AR = \frac{diam_{CC}}{\sqrt[d]{vol_{CC}}} $" src="form_3.png"/></picture>, otherwise no root: <picture><source srcset="form_4_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ AR = \frac{diam_{CC}}{vol_{CC}} $" src="form_4.png"/></picture>.  <a href="namespacecomma.html#a8c3495d8f36ab061528f00181514a64a">More...</a><br /></td></tr>
<tr class="separator:a8c3495d8f36ab061528f00181514a64a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ff61df2864666cf57c3f72132e5ea2"><td class="memTemplParams" colspan="2">template&lt;typename IndexT , typename RealT , typename IntT &gt; </td></tr>
<tr class="memitem:a37ff61df2864666cf57c3f72132e5ea2"><td class="memTemplItemLeft" align="right" valign="top">RealT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomma.html#a37ff61df2864666cf57c3f72132e5ea2">compute_AR_max_ov_min</a> (const <a class="el" href="classcomma_1_1_cell_features.html">CellFeatures</a>&lt; IndexT, RealT, IntT &gt; &amp;feat)</td></tr>
<tr class="memdesc:a37ff61df2864666cf57c3f72132e5ea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the features of a cell, compute its aspect-ratio. This returns the ratio between the diameter and the minimum edge.  <a href="namespacecomma.html#a37ff61df2864666cf57c3f72132e5ea2">More...</a><br /></td></tr>
<tr class="separator:a37ff61df2864666cf57c3f72132e5ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a263242d07618a6aaded21e7fada33004"><td class="memTemplParams" colspan="2">template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </td></tr>
<tr class="memitem:a263242d07618a6aaded21e7fada33004"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomma.html#a263242d07618a6aaded21e7fada33004">agglomerate_one_level</a> (const std::vector&lt; CoMMAIndexType &gt; &amp;adjMatrix_row_ptr, const std::vector&lt; CoMMAIndexType &gt; &amp;adjMatrix_col_ind, const std::vector&lt; CoMMAWeightType &gt; &amp;adjMatrix_areaValues, const std::vector&lt; CoMMAWeightType &gt; &amp;volumes, const std::vector&lt; std::vector&lt; CoMMAWeightType &gt; &gt; &amp;centers, const std::vector&lt; CoMMAWeightType &gt; &amp;priority_weights, const std::vector&lt; CoMMAIndexType &gt; &amp;anisotropicCompliantCells, const std::vector&lt; CoMMAIntType &gt; &amp;n_bnd_faces, bool build_anisotropic_lines, bool is_anisotropic, bool odd_line_length, CoMMAWeightType threshold_anisotropy, <a class="el" href="namespacecomma.html#a8c8213401033616d834d48d77bf359a4">CoMMASeedsPoolT</a> seed_ordering_type, std::vector&lt; CoMMAIndexType &gt; &amp;fc_to_cc, std::vector&lt; CoMMAIndexType &gt; &amp;agglomerationLines_Idx, std::vector&lt; CoMMAIndexType &gt; &amp;agglomerationLines, bool correction, CoMMAIntType dimension, CoMMAIntType goal_card, CoMMAIntType min_card, CoMMAIntType max_card, <a class="el" href="namespacecomma.html#a1202bb0cca3487ffda41fee403ac02e8">CoMMAAspectRatioT</a> aspect_ratio=<a class="el" href="namespacecomma.html#a1202bb0cca3487ffda41fee403ac02e8aa351872cd7850f5acd1c0f7d15791ac3">CoMMAAspectRatioT::DIAMETER_OVER_RADIUS</a>, CoMMAIntType singular_card_thresh=1, std::optional&lt; CoMMAIndexType &gt; max_cells_in_line=std::nullopt, CoMMAIntType fc_choice_iter=1, <a class="el" href="namespacecomma.html#a705b45ec112a3ac1bf59f760f0f4d022">CoMMANeighbourhoodT</a> neighbourhood_type=<a class="el" href="namespacecomma.html#a705b45ec112a3ac1bf59f760f0f4d022a5b91bee96d92adb448b6529d2ea8289d">CoMMANeighbourhoodT::EXTENDED</a>)</td></tr>
<tr class="memdesc:a263242d07618a6aaded21e7fada33004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main function of the agglomerator, it is used as an interface to build up all the agglomeration process. The result will be the definition of the agglomerated cells <code>fc_to_cc</code>.  <a href="namespacecomma.html#a263242d07618a6aaded21e7fada33004">More...</a><br /></td></tr>
<tr class="separator:a263242d07618a6aaded21e7fada33004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b7e1cf509b92b84db94b66033389e76"><td class="memTemplParams" colspan="2">template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </td></tr>
<tr class="memitem:a2b7e1cf509b92b84db94b66033389e76"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomma.html#a2b7e1cf509b92b84db94b66033389e76">agglomerate_one_level</a> (const <a class="el" href="classcomma_1_1_graph_args.html">GraphArgs</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt; &amp;graph, const <a class="el" href="classcomma_1_1_agglomeration_args.html">AgglomerationArgs</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt; &amp;agglo, const <a class="el" href="classcomma_1_1_anisotropic_args.html">AnisotropicArgs</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt; &amp;aniso, std::vector&lt; CoMMAIndexType &gt; &amp;fc_to_cc, std::vector&lt; CoMMAIndexType &gt; &amp;aniso_lines_indices, std::vector&lt; CoMMAIndexType &gt; &amp;aniso_lines)</td></tr>
<tr class="memdesc:a2b7e1cf509b92b84db94b66033389e76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main function of the agglomerator, it is used as an interface to build up all the agglomeration process. The result will be the definition of the agglomerated cells <code>fc_to_cc</code>.  <a href="namespacecomma.html#a2b7e1cf509b92b84db94b66033389e76">More...</a><br /></td></tr>
<tr class="separator:a2b7e1cf509b92b84db94b66033389e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18179379fcc2bb56e6b89c7b43e249c2"><td class="memTemplParams" colspan="2">template&lt;bool condition, typename typeA , typename typeB &gt; </td></tr>
<tr class="memitem:a18179379fcc2bb56e6b89c7b43e249c2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomma.html#a18179379fcc2bb56e6b89c7b43e249c2">fill_value</a> (typeA &amp;a, typeB &amp;b)</td></tr>
<tr class="memdesc:a18179379fcc2bb56e6b89c7b43e249c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign from type to another only if a compile-time condition is verified.  <a href="namespacecomma.html#a18179379fcc2bb56e6b89c7b43e249c2">More...</a><br /></td></tr>
<tr class="separator:a18179379fcc2bb56e6b89c7b43e249c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a452a16a4fa013fdd10d8768c35587750"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a452a16a4fa013fdd10d8768c35587750"><td class="memTemplItemLeft" align="right" valign="top">T constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomma.html#a452a16a4fa013fdd10d8768c35587750">_sq</a> (const T x)</td></tr>
<tr class="memdesc:a452a16a4fa013fdd10d8768c35587750"><td class="mdescLeft">&#160;</td><td class="mdescRight">Square.  <a href="namespacecomma.html#a452a16a4fa013fdd10d8768c35587750">More...</a><br /></td></tr>
<tr class="separator:a452a16a4fa013fdd10d8768c35587750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b2e63846db627820ea1a1018506e364"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0b2e63846db627820ea1a1018506e364"><td class="memTemplItemLeft" align="right" valign="top">T constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomma.html#a0b2e63846db627820ea1a1018506e364">_cb</a> (const T x)</td></tr>
<tr class="memdesc:a0b2e63846db627820ea1a1018506e364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cube.  <a href="namespacecomma.html#a0b2e63846db627820ea1a1018506e364">More...</a><br /></td></tr>
<tr class="separator:a0b2e63846db627820ea1a1018506e364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba86840a4cd3b3a35c5e9c7ab417e43b"><td class="memTemplParams" colspan="2">template&lt;unsigned int p, typename T &gt; </td></tr>
<tr class="memitem:aba86840a4cd3b3a35c5e9c7ab417e43b"><td class="memTemplItemLeft" align="right" valign="top">T constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomma.html#aba86840a4cd3b3a35c5e9c7ab417e43b">int_power</a> (const T x)</td></tr>
<tr class="memdesc:aba86840a4cd3b3a35c5e9c7ab417e43b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raise a quantity to an integer power.  <a href="namespacecomma.html#aba86840a4cd3b3a35c5e9c7ab417e43b">More...</a><br /></td></tr>
<tr class="separator:aba86840a4cd3b3a35c5e9c7ab417e43b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c9a93345d5c34823f57fa526e438411"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3c9a93345d5c34823f57fa526e438411"><td class="memTemplItemLeft" align="right" valign="top">bool constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomma.html#a3c9a93345d5c34823f57fa526e438411">dot_deviate</a> (const T dot)</td></tr>
<tr class="memdesc:a3c9a93345d5c34823f57fa526e438411"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell whether the dot product given as input comes from two parallel vectors. Compared against <a class="el" href="namespacecomma.html#a75164a303f92061683959fa690d67906">deviate_thresh</a>.  <a href="namespacecomma.html#a3c9a93345d5c34823f57fa526e438411">More...</a><br /></td></tr>
<tr class="separator:a3c9a93345d5c34823f57fa526e438411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e43c30768d45d4f1f643f2f8be53f5d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0e43c30768d45d4f1f643f2f8be53f5d"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomma.html#a0e43c30768d45d4f1f643f2f8be53f5d">dot_product</a> (const std::vector&lt; T &gt; &amp;a, const std::vector&lt; T &gt; &amp;b)</td></tr>
<tr class="memdesc:a0e43c30768d45d4f1f643f2f8be53f5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the dot product between two vectors. No check on size is performed.  <a href="namespacecomma.html#a0e43c30768d45d4f1f643f2f8be53f5d">More...</a><br /></td></tr>
<tr class="separator:a0e43c30768d45d4f1f643f2f8be53f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fda6288b7b5c19904abf0312557c774"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3fda6288b7b5c19904abf0312557c774"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomma.html#a3fda6288b7b5c19904abf0312557c774">get_direction</a> (const std::vector&lt; T &gt; &amp;a, const std::vector&lt; T &gt; &amp;b, std::vector&lt; T &gt; &amp;dir)</td></tr>
<tr class="memdesc:a3fda6288b7b5c19904abf0312557c774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the direction from point <code>a</code> to point <code>b</code> and store it as unit vector in <code>dir</code>.  <a href="namespacecomma.html#a3fda6288b7b5c19904abf0312557c774">More...</a><br /></td></tr>
<tr class="separator:a3fda6288b7b5c19904abf0312557c774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39eb676bbec9475d7b0b5a6186b5f3d0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a39eb676bbec9475d7b0b5a6186b5f3d0"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomma.html#a39eb676bbec9475d7b0b5a6186b5f3d0">squared_euclidean_distance</a> (const std::vector&lt; T &gt; &amp;a, const std::vector&lt; T &gt; &amp;b)</td></tr>
<tr class="memdesc:a39eb676bbec9475d7b0b5a6186b5f3d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the squared Euclidean distance between two points seen as vectors. We use vectors because we can have both 2- and 3D points (also we can have 3D points even if the dimension given to CoMMA is 2D, e.g., with CODA pseudo-2D meshes). The dimension used as reference is the one of the first point.  <a href="namespacecomma.html#a39eb676bbec9475d7b0b5a6186b5f3d0">More...</a><br /></td></tr>
<tr class="separator:a39eb676bbec9475d7b0b5a6186b5f3d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab712cf58df5dacc470f08332abdde7ec"><td class="memTemplParams" colspan="2">template&lt;typename CoMMAContainerPairType &gt; </td></tr>
<tr class="memitem:ab712cf58df5dacc470f08332abdde7ec"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename CoMMAContainerPairType::value_type::first_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomma.html#ab712cf58df5dacc470f08332abdde7ec">vector_of_first_elements</a> (const CoMMAContainerPairType &amp;cont)</td></tr>
<tr class="memdesc:ab712cf58df5dacc470f08332abdde7ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a container of pairs, return a vector with first elements only.  <a href="namespacecomma.html#ab712cf58df5dacc470f08332abdde7ec">More...</a><br /></td></tr>
<tr class="separator:ab712cf58df5dacc470f08332abdde7ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81affca718f9c9927cfb82c317c8239e"><td class="memTemplParams" colspan="2">template&lt;typename KeyT , typename ValueT &gt; </td></tr>
<tr class="memitem:a81affca718f9c9927cfb82c317c8239e"><td class="memTemplItemLeft" align="right" valign="top">std::unordered_set&lt; KeyT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomma.html#a81affca718f9c9927cfb82c317c8239e">d_keys_to_set</a> (const std::unordered_map&lt; KeyT, ValueT &gt; &amp;dict)</td></tr>
<tr class="memdesc:a81affca718f9c9927cfb82c317c8239e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function for creating a set out of the keys of a map.  <a href="namespacecomma.html#a81affca718f9c9927cfb82c317c8239e">More...</a><br /></td></tr>
<tr class="separator:a81affca718f9c9927cfb82c317c8239e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5193675e5abbdc422bcb8be506e6c08c"><td class="memTemplParams" colspan="2">template&lt;typename IndexT , typename IntT &gt; </td></tr>
<tr class="memitem:a5193675e5abbdc422bcb8be506e6c08c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomma.html#a5193675e5abbdc422bcb8be506e6c08c">filter_cells_by_n_edges</a> (const std::vector&lt; IndexT &gt; &amp;indices, const std::vector&lt; IntT &gt; &amp;n_bnd_faces, const std::unordered_set&lt; IntT &gt; &amp;allowed, std::vector&lt; IndexT &gt; &amp;filtered)</td></tr>
<tr class="memdesc:a5193675e5abbdc422bcb8be506e6c08c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the connectivity of the graph, filter cells keeping only those with the desired number of edges / neighbours.  <a href="namespacecomma.html#a5193675e5abbdc422bcb8be506e6c08c">More...</a><br /></td></tr>
<tr class="separator:a5193675e5abbdc422bcb8be506e6c08c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3653181db03b3ea76722462c3b3e02b"><td class="memTemplParams" colspan="2">template&lt;typename IndexT , typename DistT &gt; </td></tr>
<tr class="memitem:ae3653181db03b3ea76722462c3b3e02b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomma.html#ae3653181db03b3ea76722462c3b3e02b">compute_neighbourhood_based_wall_distance</a> (const std::vector&lt; IndexT &gt; &amp;neigh_idxs, const std::vector&lt; IndexT &gt; &amp;neighs, const std::vector&lt; IndexT &gt; &amp;wall, std::vector&lt; DistT &gt; &amp;dist)</td></tr>
<tr class="memdesc:ae3653181db03b3ea76722462c3b3e02b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a neighbourhood-base wall-distance, that is, the distance of a given cell from a wall is the number of cells though which the minimum path starting from the cell and ending at the wall. For example, in a Cartesian grids this is equivalent to the minimum of the Manhattan distance.<br  />
 If the vector defining the wall is empty, return negative values.<br  />
 If a cell is unconnected to the domain with the wall, its distance will be negative.<br  />
 It takes a compressed version of the connectivity of the mesh. It uses a BFS algorithm to visit all the cells.  <a href="namespacecomma.html#ae3653181db03b3ea76722462c3b3e02b">More...</a><br /></td></tr>
<tr class="separator:ae3653181db03b3ea76722462c3b3e02b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ae843c64bc9e371bd460fe8d040c80e2b"><td class="memItemLeft" align="right" valign="top">constexpr CoMMAIntT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecomma.html#ae843c64bc9e371bd460fe8d040c80e2b">iter_agglo_max_iter</a> = 4</td></tr>
<tr class="memdesc:ae843c64bc9e371bd460fe8d040c80e2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum allowed iterations for the iterative algorithm, see <a class="el" href="classcomma_1_1_agglomerator___iterative.html">Agglomerator_Iterative</a>.  <a href="namespacecomma.html#ae843c64bc9e371bd460fe8d040c80e2b">More...</a><br /></td></tr>
<tr class="separator:ae843c64bc9e371bd460fe8d040c80e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75164a303f92061683959fa690d67906"><td class="memItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecomma.html#a75164a303f92061683959fa690d67906">deviate_thresh</a> = 0.9396926207859084</td></tr>
<tr class="memdesc:a75164a303f92061683959fa690d67906"><td class="mdescLeft">&#160;</td><td class="mdescRight">Threshold used in combination with a dot product to tell whether two vector deviate. It is set to <picture><source srcset="form_27_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \cos(20^\circ) $" src="form_27.png"/></picture>.  <a href="namespacecomma.html#a75164a303f92061683959fa690d67906">More...</a><br /></td></tr>
<tr class="separator:a75164a303f92061683959fa690d67906"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a1202bb0cca3487ffda41fee403ac02e8" name="a1202bb0cca3487ffda41fee403ac02e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1202bb0cca3487ffda41fee403ac02e8">&#9670;&#160;</a></span>CoMMAAspectRatioT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacecomma.html#a1202bb0cca3487ffda41fee403ac02e8">comma::CoMMAAspectRatioT</a> : CoMMAIntT</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of aspect-ratio. Notation: </p>
<ul>
<li><picture><source srcset="form_8_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ fc $" src="form_8.png"/></picture> = Fine Cell, <picture><source srcset="form_9_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ CC $" src="form_9.png"/></picture> = Coarse cell = <picture><source srcset="form_10_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \{fc_i\}_i $" src="form_10.png"/></picture>:<br  />
</li>
<li>Distance: <picture><source srcset="form_11_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ d(x,\, y) $" src="form_11.png"/></picture></li>
<li>Measure: in 3D, volume of the CC, <picture><source srcset="form_12_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ vol(CC) $" src="form_12.png"/></picture><br  />
</li>
<li>Radius: approximation of the characteristic length <picture><source srcset="form_13_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \rho(CC) = \sqrt[dim]{vol(CC)} $" src="form_13.png"/></picture><br  />
</li>
<li>Barycenter: <picture><source srcset="form_14_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ x^b_{CC} = \sum_{fc \in CC} vol_{fc} x^b_{fc} $" src="form_14.png"/></picture><br  />
</li>
<li>Diameter: <picture><source srcset="form_15_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ diam = max_{fc_i, fc_j \in CC} d(x^b_{fc_i},\, x^b_{fc_j}) $" src="form_15.png"/></picture><br  />
</li>
<li>Perimeter: external weights, <picture><source srcset="form_16_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \pi(CC) $" src="form_16.png"/></picture><br  />
</li>
<li>Internal weights: sum of the surfaces of the internal facets, <picture><source srcset="form_17_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \sigma(CC) $" src="form_17.png"/></picture> </li>
</ul>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1202bb0cca3487ffda41fee403ac02e8aa351872cd7850f5acd1c0f7d15791ac3" name="a1202bb0cca3487ffda41fee403ac02e8aa351872cd7850f5acd1c0f7d15791ac3"></a>DIAMETER_OVER_RADIUS&#160;</td><td class="fielddoc"><p >Diameter over radius, <picture><source srcset="form_18_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ AR = \frac{diam(CC)}{\rho(CC)} $" src="form_18.png"/></picture> </p>
</td></tr>
<tr><td class="fieldname"><a id="a1202bb0cca3487ffda41fee403ac02e8ad95bf49ebe2c8dffb7925f1f6c8ea501" name="a1202bb0cca3487ffda41fee403ac02e8ad95bf49ebe2c8dffb7925f1f6c8ea501"></a>DIAMETER_OVER_MIN_EDGE&#160;</td><td class="fielddoc"><p >Diameter over minimum edge ( <picture><source srcset="form_19_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ =min_{fc_i, fc_j \in CC}
 d(x^b_{fc_i},\, x^b_{fc_j}) $" src="form_19.png"/></picture>) </p>
</td></tr>
<tr><td class="fieldname"><a id="a1202bb0cca3487ffda41fee403ac02e8aed2ee02285e0e6f65604cec18a72906a" name="a1202bb0cca3487ffda41fee403ac02e8aed2ee02285e0e6f65604cec18a72906a"></a>DIAMETER&#160;</td><td class="fielddoc"><p >Diameter, <picture><source srcset="form_20_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ AR = diam(CC) $" src="form_20.png"/></picture> </p>
</td></tr>
<tr><td class="fieldname"><a id="a1202bb0cca3487ffda41fee403ac02e8a24e459b8a19def0f2202bd0007fc5f51" name="a1202bb0cca3487ffda41fee403ac02e8a24e459b8a19def0f2202bd0007fc5f51"></a>ONE_OVER_MEASURE&#160;</td><td class="fielddoc"><p >One over the measure (e.g., volume) of the cell, <picture><source srcset="form_21_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ AR = \frac{1}{vol(CC)} $" src="form_21.png"/></picture> </p>
</td></tr>
<tr><td class="fieldname"><a id="a1202bb0cca3487ffda41fee403ac02e8a338fbd50e6953c9f8d4bed80203ab293" name="a1202bb0cca3487ffda41fee403ac02e8a338fbd50e6953c9f8d4bed80203ab293"></a>ONE_OVER_INTERNAL_WEIGHTS&#160;</td><td class="fielddoc"><p >One over the internal weights, <picture><source srcset="form_22_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ AR = \frac{1}{\sigma(CC)} $" src="form_22.png"/></picture> </p>
</td></tr>
<tr><td class="fieldname"><a id="a1202bb0cca3487ffda41fee403ac02e8af88e6862b1602f233d2d495a9b1d1e98" name="a1202bb0cca3487ffda41fee403ac02e8af88e6862b1602f233d2d495a9b1d1e98"></a>PERIMETER_OVER_RADIUS&#160;</td><td class="fielddoc"><p >Perimeter over radius, <picture><source srcset="form_23_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ AR = \frac{\pi(CC)}{\rho(CC)} $" src="form_23.png"/></picture> </p>
</td></tr>
<tr><td class="fieldname"><a id="a1202bb0cca3487ffda41fee403ac02e8a77ecfee8b6ce57670d02fceec49c89d5" name="a1202bb0cca3487ffda41fee403ac02e8a77ecfee8b6ce57670d02fceec49c89d5"></a>EXTERNAL_WEIGHTS&#160;</td><td class="fielddoc"><p >External weights, that is, perimeter, <picture><source srcset="form_24_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ AR = \pi(CC) $" src="form_24.png"/></picture> </p>
</td></tr>
<tr><td class="fieldname"><a id="a1202bb0cca3487ffda41fee403ac02e8a8e8c23ebd7ed4f6183e3b0d87986dfed" name="a1202bb0cca3487ffda41fee403ac02e8a8e8c23ebd7ed4f6183e3b0d87986dfed"></a>MAX_BARY_DIST_OVER_RADIUS&#160;</td><td class="fielddoc"><p >Maximum FC-center distance from barycenter over radius </p>
</td></tr>
<tr><td class="fieldname"><a id="a1202bb0cca3487ffda41fee403ac02e8adea3279d5aefb79b3587092acda0310c" name="a1202bb0cca3487ffda41fee403ac02e8adea3279d5aefb79b3587092acda0310c"></a>MAX_OVER_MIN_BARY_DIST&#160;</td><td class="fielddoc"><p >Maximum over minimum FC-center distance from barycenter </p>
</td></tr>
<tr><td class="fieldname"><a id="a1202bb0cca3487ffda41fee403ac02e8a40c0eaf07c674d996bc2044ceccce8ce" name="a1202bb0cca3487ffda41fee403ac02e8a40c0eaf07c674d996bc2044ceccce8ce"></a>ALGEBRAIC_PERIMETER_OVER_MEASURE&#160;</td><td class="fielddoc"><p >Algebraic-like perimeter over measure, that is, external weights over cell weight </p>
</td></tr>
</table>

</div>
</div>
<a id="a6676cd5a4d3dbf9141f8c7bc87617be8" name="a6676cd5a4d3dbf9141f8c7bc87617be8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6676cd5a4d3dbf9141f8c7bc87617be8">&#9670;&#160;</a></span>CoMMACellT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacecomma.html#a6676cd5a4d3dbf9141f8c7bc87617be8">comma::CoMMACellT</a> : CoMMAIntT</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of an element according to its boundary faces / edges The terms come from the NIA paper: Nishikawa, Diskin, Thomas... </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6676cd5a4d3dbf9141f8c7bc87617be8ada6f7a085b1f7f2125ce30f5e02db53c" name="a6676cd5a4d3dbf9141f8c7bc87617be8ada6f7a085b1f7f2125ce30f5e02db53c"></a>INTERIOR&#160;</td><td class="fielddoc"><p >Interior cell, no boundary faces. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6676cd5a4d3dbf9141f8c7bc87617be8a4f18a70072d52370244908b93cf13e85" name="a6676cd5a4d3dbf9141f8c7bc87617be8a4f18a70072d52370244908b93cf13e85"></a>VALLEY&#160;</td><td class="fielddoc"><p >Valley, one boundary face. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6676cd5a4d3dbf9141f8c7bc87617be8aaa4cdfbb2d1efc15da1728bbc125e9f1" name="a6676cd5a4d3dbf9141f8c7bc87617be8aaa4cdfbb2d1efc15da1728bbc125e9f1"></a>RIDGE&#160;</td><td class="fielddoc"><p >Ridge, two boundary faces. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6676cd5a4d3dbf9141f8c7bc87617be8a39ad49623cc576b66fc391bd2bc1c7cf" name="a6676cd5a4d3dbf9141f8c7bc87617be8a39ad49623cc576b66fc391bd2bc1c7cf"></a>CORNER&#160;</td><td class="fielddoc"><p >Corners, three boundary faces. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6676cd5a4d3dbf9141f8c7bc87617be8ac5e925f6e54a010df01d51f9b4e6f981" name="a6676cd5a4d3dbf9141f8c7bc87617be8ac5e925f6e54a010df01d51f9b4e6f981"></a>EXTREME&#160;</td><td class="fielddoc"><p >Extreme value, should not be used. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6676cd5a4d3dbf9141f8c7bc87617be8a0309283de9cefb87968e32825c3418ec" name="a6676cd5a4d3dbf9141f8c7bc87617be8a0309283de9cefb87968e32825c3418ec"></a>N_CELL_TYPES&#160;</td><td class="fielddoc"><p >Total number of values. </p>
</td></tr>
</table>

</div>
</div>
<a id="a705b45ec112a3ac1bf59f760f0f4d022" name="a705b45ec112a3ac1bf59f760f0f4d022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a705b45ec112a3ac1bf59f760f0f4d022">&#9670;&#160;</a></span>CoMMANeighbourhoodT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacecomma.html#a705b45ec112a3ac1bf59f760f0f4d022">comma::CoMMANeighbourhoodT</a> : CoMMAIntT</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of neighbourhood (of a coarse cell) considered when agglomerating. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a705b45ec112a3ac1bf59f760f0f4d022a5b91bee96d92adb448b6529d2ea8289d" name="a705b45ec112a3ac1bf59f760f0f4d022a5b91bee96d92adb448b6529d2ea8289d"></a>EXTENDED&#160;</td><td class="fielddoc"><p >Extended, all neighbours of the coarse cell. </p>
</td></tr>
<tr><td class="fieldname"><a id="a705b45ec112a3ac1bf59f760f0f4d022a681aa75b2dff7410008df1396b15fe35" name="a705b45ec112a3ac1bf59f760f0f4d022a681aa75b2dff7410008df1396b15fe35"></a>PURE_FRONT&#160;</td><td class="fielddoc"><p >Pure front, only neighbours of the last added fine cell. </p>
</td></tr>
</table>

</div>
</div>
<a id="a8c8213401033616d834d48d77bf359a4" name="a8c8213401033616d834d48d77bf359a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c8213401033616d834d48d77bf359a4">&#9670;&#160;</a></span>CoMMASeedsPoolT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacecomma.html#a8c8213401033616d834d48d77bf359a4">comma::CoMMASeedsPoolT</a> : CoMMAIntT</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of seeds pool ordering. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8c8213401033616d834d48d77bf359a4a7340b7195c9071cd34c7d9a633a3d857" name="a8c8213401033616d834d48d77bf359a4a7340b7195c9071cd34c7d9a633a3d857"></a>BOUNDARY_PRIORITY&#160;</td><td class="fielddoc"><p >The number of boundary faces has higher priority </p>
</td></tr>
<tr><td class="fieldname"><a id="a8c8213401033616d834d48d77bf359a4ae3fbc583bddef8540a06125ed1e7dc79" name="a8c8213401033616d834d48d77bf359a4ae3fbc583bddef8540a06125ed1e7dc79"></a>NEIGHBOURHOOD_PRIORITY&#160;</td><td class="fielddoc"><p >The neighbourhood has highest priority (neighbours of coarse cells have higher priority) </p>
</td></tr>
<tr><td class="fieldname"><a id="a8c8213401033616d834d48d77bf359a4a29ddaed9cc8cda952d02296b79010787" name="a8c8213401033616d834d48d77bf359a4a29ddaed9cc8cda952d02296b79010787"></a>BOUNDARY_PRIORITY_ONE_POINT_INIT&#160;</td><td class="fielddoc"><p >The number of boundary faces has higher priority, and initialize with one point only then let evolve </p>
</td></tr>
<tr><td class="fieldname"><a id="a8c8213401033616d834d48d77bf359a4a8c23e18158e720cbd348f98e50376a5d" name="a8c8213401033616d834d48d77bf359a4a8c23e18158e720cbd348f98e50376a5d"></a>NEIGHBOURHOOD_PRIORITY_ONE_POINT_INIT&#160;</td><td class="fielddoc"><p >The neighbourhood has higher priority, and initialize with one point only then let evolve </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a0b2e63846db627820ea1a1018506e364" name="a0b2e63846db627820ea1a1018506e364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b2e63846db627820ea1a1018506e364">&#9670;&#160;</a></span>_cb()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T constexpr comma::_cb </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cube. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the quantity </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The quantity </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the cube of <code>x</code> </dd></dl>

</div>
</div>
<a id="a452a16a4fa013fdd10d8768c35587750" name="a452a16a4fa013fdd10d8768c35587750"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a452a16a4fa013fdd10d8768c35587750">&#9670;&#160;</a></span>_sq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T constexpr comma::_sq </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Square. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the quantity </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The quantity </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the square of <code>x</code> </dd></dl>

</div>
</div>
<a id="a2b7e1cf509b92b84db94b66033389e76" name="a2b7e1cf509b92b84db94b66033389e76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b7e1cf509b92b84db94b66033389e76">&#9670;&#160;</a></span>agglomerate_one_level() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void comma::agglomerate_one_level </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcomma_1_1_graph_args.html">GraphArgs</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt; &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcomma_1_1_agglomeration_args.html">AgglomerationArgs</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt; &amp;&#160;</td>
          <td class="paramname"><em>agglo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcomma_1_1_anisotropic_args.html">AnisotropicArgs</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt; &amp;&#160;</td>
          <td class="paramname"><em>aniso</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; CoMMAIndexType &gt; &amp;&#160;</td>
          <td class="paramname"><em>fc_to_cc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; CoMMAIndexType &gt; &amp;&#160;</td>
          <td class="paramname"><em>aniso_lines_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; CoMMAIndexType &gt; &amp;&#160;</td>
          <td class="paramname"><em>aniso_lines</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Main function of the agglomerator, it is used as an interface to build up all the agglomeration process. The result will be the definition of the agglomerated cells <code>fc_to_cc</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CoMMAIndexType</td><td>the CoMMA index type for the global index of the mesh </td></tr>
    <tr><td class="paramname">CoMMAWeightType</td><td>the CoMMA weight type for the weights (volume or area) of the nodes or edges of the Mesh </td></tr>
    <tr><td class="paramname">CoMMAIntType</td><td>the CoMMA type for integers </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>Definition of the graph, see <a class="el" href="classcomma_1_1_graph_args.html" title="Convenient class holding arguments defining the graph.">GraphArgs</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">agglo</td><td>Parametrization of the isotropic agglomeration algorithm, see <a class="el" href="classcomma_1_1_agglomeration_args.html" title="Convenient class holding arguments for the parametrization of the agglomeration algorithm.">AgglomerationArgs</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aniso</td><td>Parametrization of the anisotropic agglomeration algorithm, see <a class="el" href="classcomma_1_1_anisotropic_args.html" title="Convenient class holding arguments for the parametrization of the anisotropic agglomeration algorithm...">AnisotropicArgs</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fc_to_cc</td><td>Vector telling the ID of the coarse cell to which a fine cell belongs after agglomeration. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">aniso_lines_indices</td><td>Connectivity for the agglomeration lines </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">aniso_lines</td><td>Vector storing all the elements of the anisotropic lines</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This version is just a wrapper around the other agglomerate_one_level </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>Copyright  2024 ONERA </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Nicolas Lantos, Alberto Remigi, and Riccardo Milani </dd></dl>
<dl class="section user"><dt>Contributor</dt><dd>Karim Anemiche </dd></dl>
<dl class="section user"><dt>License</dt><dd>This project is released under the Mozilla Public License 2.0, see <a href="https://mozilla.org/MPL/2.0/">https://mozilla.org/MPL/2.0/</a> </dd></dl>

</div>
</div>
<a id="a263242d07618a6aaded21e7fada33004" name="a263242d07618a6aaded21e7fada33004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a263242d07618a6aaded21e7fada33004">&#9670;&#160;</a></span>agglomerate_one_level() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void comma::agglomerate_one_level </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; CoMMAIndexType &gt; &amp;&#160;</td>
          <td class="paramname"><em>adjMatrix_row_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; CoMMAIndexType &gt; &amp;&#160;</td>
          <td class="paramname"><em>adjMatrix_col_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; CoMMAWeightType &gt; &amp;&#160;</td>
          <td class="paramname"><em>adjMatrix_areaValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; CoMMAWeightType &gt; &amp;&#160;</td>
          <td class="paramname"><em>volumes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; CoMMAWeightType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>centers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; CoMMAWeightType &gt; &amp;&#160;</td>
          <td class="paramname"><em>priority_weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; CoMMAIndexType &gt; &amp;&#160;</td>
          <td class="paramname"><em>anisotropicCompliantCells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; CoMMAIntType &gt; &amp;&#160;</td>
          <td class="paramname"><em>n_bnd_faces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>build_anisotropic_lines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_anisotropic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>odd_line_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoMMAWeightType&#160;</td>
          <td class="paramname"><em>threshold_anisotropy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecomma.html#a8c8213401033616d834d48d77bf359a4">CoMMASeedsPoolT</a>&#160;</td>
          <td class="paramname"><em>seed_ordering_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; CoMMAIndexType &gt; &amp;&#160;</td>
          <td class="paramname"><em>fc_to_cc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; CoMMAIndexType &gt; &amp;&#160;</td>
          <td class="paramname"><em>agglomerationLines_Idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; CoMMAIndexType &gt; &amp;&#160;</td>
          <td class="paramname"><em>agglomerationLines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>correction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoMMAIntType&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoMMAIntType&#160;</td>
          <td class="paramname"><em>goal_card</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoMMAIntType&#160;</td>
          <td class="paramname"><em>min_card</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoMMAIntType&#160;</td>
          <td class="paramname"><em>max_card</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecomma.html#a1202bb0cca3487ffda41fee403ac02e8">CoMMAAspectRatioT</a>&#160;</td>
          <td class="paramname"><em>aspect_ratio</em> = <code><a class="el" href="namespacecomma.html#a1202bb0cca3487ffda41fee403ac02e8aa351872cd7850f5acd1c0f7d15791ac3">CoMMAAspectRatioT::DIAMETER_OVER_RADIUS</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoMMAIntType&#160;</td>
          <td class="paramname"><em>singular_card_thresh</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; CoMMAIndexType &gt;&#160;</td>
          <td class="paramname"><em>max_cells_in_line</em> = <code>std::nullopt</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoMMAIntType&#160;</td>
          <td class="paramname"><em>fc_choice_iter</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecomma.html#a705b45ec112a3ac1bf59f760f0f4d022">CoMMANeighbourhoodT</a>&#160;</td>
          <td class="paramname"><em>neighbourhood_type</em> = <code><a class="el" href="namespacecomma.html#a705b45ec112a3ac1bf59f760f0f4d022a5b91bee96d92adb448b6529d2ea8289d">CoMMANeighbourhoodT::EXTENDED</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Main function of the agglomerator, it is used as an interface to build up all the agglomeration process. The result will be the definition of the agglomerated cells <code>fc_to_cc</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CoMMAIndexType</td><td>the CoMMA index type for the global index of the mesh </td></tr>
    <tr><td class="paramname">CoMMAWeightType</td><td>the CoMMA weight type for the weights (volume or area) of the nodes or edges of the Mesh </td></tr>
    <tr><td class="paramname">CoMMAIntType</td><td>the CoMMA type for integers </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">adjMatrix_row_ptr</td><td>the row pointer of the CRS representation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">adjMatrix_col_ind</td><td>the column index of the CRS representation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">adjMatrix_areaValues</td><td>the weight of the CRS representation (in CoMMA case will be the area of the faces that in the graph representation are the edges between two nodes represented by the cell centers. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">volumes</td><td>The volumes of the cells </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">centers</td><td>Cell centers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">priority_weights</td><td>Weights used to set the order telling where to start agglomerating. The higher the weight, the higher the priority </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">anisotropicCompliantCells</td><td>List of cells which have to be looked for anisotropy </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_bnd_faces</td><td>Vector telling how many boundary faces each cell has </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">build_anisotropic_lines</td><td>Whether lines joining the anisotropic cells should be built, otherwise, if the anisotropic agglomeration is activated, the lines should be provided, see <code>agglomerationLines_Idx</code> and <code>agglomerationLines</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_anisotropic</td><td>Whether to consider an anisotropic agglomeration </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">odd_line_length</td><td>Whether anisotropic lines with odd length are allowed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">threshold_anisotropy</td><td>Value of the aspect-ratio above which a cell is considered as anisotropic. If negative, all compliant cells are considered as anisotropic </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seed_ordering_type</td><td>Type of ordering for the seeds of the coarse cells. Possible values (see <a class="el" href="namespacecomma.html#a8c8213401033616d834d48d77bf359a4">CoMMASeedsPoolT</a>):<ul>
<li>0: The number of boundary faces has highest priority</li>
<li>1: The neighbourhood has highest priority (neighbours of coarse cells have priority)</li>
<li>10: The number of boundary faces has highest priority, and initialize with one point only then let evolve</li>
<li>11: The neighbourhood has highest priority, and initialize with one point only then let evolve </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fc_to_cc</td><td>Vector telling the ID of the coarse cell to which a fine cell belongs after agglomeration. The vector is cleared and then resized to the right size. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">agglomerationLines_Idx</td><td>Connectivity for the agglomeration lines: each element points to a particular element in the vector <code>agglomerationLines</code> </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">agglomerationLines</td><td>Vector storing all the elements of the anisotropic lines </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">correction</td><td>Whether to apply correction step (avoid isolated cells) after agglomeration </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dimension</td><td>Dimensionality of the problem, 2- or 3D </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">goal_card</td><td>Desired cardinality of the coarse cells (might not be ensured) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_card</td><td>Minimum cardinality accepted for the coarse cells </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_card</td><td>Maximum cardinality accepted for the coarse cells </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aspect_ratio</td><td>Type of aspect-ratio (see <a class="el" href="namespacecomma.html#a1202bb0cca3487ffda41fee403ac02e8">CoMMAAspectRatioT</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">singular_card_thresh</td><td>(optional, default=1) Cardinality below which a coarse is considered as singular, hence, compliant for correction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_cells_in_line</td><td>[Optional] Maximum number of cells in an anisotropic line; when this value is reached, all reaming cells are discarded, hence considered as isotropic </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fc_choice_iter</td><td>(optional, default=1) Number of iterations allowed for the algorithm choosing which fine cell to add next. The cost grows exponentially, hence use small values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">neighbourhood_type</td><td>(optional, default=Extended) Type of neighbourhood to use when growing a coarse cell. See <a class="el" href="namespacecomma.html#a705b45ec112a3ac1bf59f760f0f4d022">CoMMANeighbourhoodT</a> for more details. Two alternatives:<ul>
<li>Extended: requested with 0, standard algorithm where we consider every neighbour of the coarse cell as candidate.</li>
<li>Pure Front Advancing: requested with 1, only direct neighbours of the last added cell are candidates. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">invalid_argument</td><td>whenever dimension is not 2 nor 3, cardinalities are smaller than 1 or not in order, line building is disabled but lines are not provided, or number of iterations is negative or greater than <a class="el" href="namespacecomma.html#ae843c64bc9e371bd460fe8d040c80e2b">iter_agglo_max_iter</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section copyright"><dt>Copyright</dt><dd>Copyright  2024 ONERA </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Nicolas Lantos, Alberto Remigi, and Riccardo Milani </dd></dl>
<dl class="section user"><dt>Contributor</dt><dd>Karim Anemiche </dd></dl>
<dl class="section user"><dt>License</dt><dd>This project is released under the Mozilla Public License 2.0, see <a href="https://mozilla.org/MPL/2.0/">https://mozilla.org/MPL/2.0/</a> </dd></dl>

</div>
</div>
<a id="a37ff61df2864666cf57c3f72132e5ea2" name="a37ff61df2864666cf57c3f72132e5ea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37ff61df2864666cf57c3f72132e5ea2">&#9670;&#160;</a></span>compute_AR_max_ov_min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexT , typename RealT , typename IntT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RealT comma::compute_AR_max_ov_min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcomma_1_1_cell_features.html">CellFeatures</a>&lt; IndexT, RealT, IntT &gt; &amp;&#160;</td>
          <td class="paramname"><em>feat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given the features of a cell, compute its aspect-ratio. This returns the ratio between the diameter and the minimum edge. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type used for the features </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">feat</td><td>Cell features </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the aspect-ratio </dd></dl>

</div>
</div>
<a id="a8c3495d8f36ab061528f00181514a64a" name="a8c3495d8f36ab061528f00181514a64a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c3495d8f36ab061528f00181514a64a">&#9670;&#160;</a></span>compute_AR_max_ov_radius()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexT , typename RealT , typename IntT , int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RealT comma::compute_AR_max_ov_radius </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcomma_1_1_cell_features.html">CellFeatures</a>&lt; IndexT, RealT, IntT &gt; &amp;&#160;</td>
          <td class="paramname"><em>feat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given the features of a cell, compute its aspect-ratio. This uses the diameter and the measure.<br  />
 In 3D: <picture><source srcset="form_0_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ AR = \frac{diam_{CC}}{\sqrt{vol_{CC}}} $" src="form_0.png"/></picture> <br  />
 In 2D: <picture><source srcset="form_1_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ AR = \frac{diam_{CC}}{\sqrt[3]{vol_{CC}}} $" src="form_1.png"/></picture> (Recall that in 2D the volume is the surface) <br  />
 Generally, for dimension <picture><source srcset="form_2_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ d &gt;=2 $" src="form_2.png"/></picture>: <picture><source srcset="form_3_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ AR = \frac{diam_{CC}}{\sqrt[d]{vol_{CC}}} $" src="form_3.png"/></picture>, otherwise no root: <picture><source srcset="form_4_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ AR = \frac{diam_{CC}}{vol_{CC}} $" src="form_4.png"/></picture>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type used for the features </td></tr>
    <tr><td class="paramname">dim</td><td>Dimension (e.g., 2D) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">feat</td><td>Cell features </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the aspect-ratio </dd></dl>

</div>
</div>
<a id="ae3653181db03b3ea76722462c3b3e02b" name="ae3653181db03b3ea76722462c3b3e02b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3653181db03b3ea76722462c3b3e02b">&#9670;&#160;</a></span>compute_neighbourhood_based_wall_distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexT , typename DistT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void comma::compute_neighbourhood_based_wall_distance </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; IndexT &gt; &amp;&#160;</td>
          <td class="paramname"><em>neigh_idxs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; IndexT &gt; &amp;&#160;</td>
          <td class="paramname"><em>neighs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; IndexT &gt; &amp;&#160;</td>
          <td class="paramname"><em>wall</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; DistT &gt; &amp;&#160;</td>
          <td class="paramname"><em>dist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a neighbourhood-base wall-distance, that is, the distance of a given cell from a wall is the number of cells though which the minimum path starting from the cell and ending at the wall. For example, in a Cartesian grids this is equivalent to the minimum of the Manhattan distance.<br  />
 If the vector defining the wall is empty, return negative values.<br  />
 If a cell is unconnected to the domain with the wall, its distance will be negative.<br  />
 It takes a compressed version of the connectivity of the mesh. It uses a BFS algorithm to visit all the cells. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IndexT</td><td>Type for cell indices </td></tr>
    <tr><td class="paramname">DistT</td><td>Type for distance (should be signed) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">neigh_idxs</td><td>Indices used to recover the neighbours of each cells provided in <code>neighs</code>. The length is <picture><source srcset="form_29_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ N_{cells} + 1 $" src="form_29.png"/></picture> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">neighs</td><td>Neighbours of the cells </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wall</td><td>Cells composing the wall from which the distance is computed </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dist</td><td>Distance from the wall. This vector is resized inside the function to hold all the cells </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is <b>experimental</b>. Moreover, since CoMMA has knowledge of the current domain only, this function might not give the right result if the domain has been partitioned. It is advised to use this function only when considering one domain only. </dd></dl>

</div>
</div>
<a id="a81affca718f9c9927cfb82c317c8239e" name="a81affca718f9c9927cfb82c317c8239e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81affca718f9c9927cfb82c317c8239e">&#9670;&#160;</a></span>d_keys_to_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT , typename ValueT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_set&lt; KeyT &gt; comma::d_keys_to_set </td>
          <td>(</td>
          <td class="paramtype">const std::unordered_map&lt; KeyT, ValueT &gt; &amp;&#160;</td>
          <td class="paramname"><em>dict</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function for creating a set out of the keys of a map. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyT</td><td>Type of the keys of the map </td></tr>
    <tr><td class="paramname">ValueT</td><td>Type of the values of the map </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dict</td><td>A map </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a set </dd></dl>

</div>
</div>
<a id="a3c9a93345d5c34823f57fa526e438411" name="a3c9a93345d5c34823f57fa526e438411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c9a93345d5c34823f57fa526e438411">&#9670;&#160;</a></span>dot_deviate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool constexpr comma::dot_deviate </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>dot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tell whether the dot product given as input comes from two parallel vectors. Compared against <a class="el" href="namespacecomma.html#a75164a303f92061683959fa690d67906">deviate_thresh</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Input type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dot</td><td>Dot product </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if higher than a reference threshold </dd></dl>

</div>
</div>
<a id="a0e43c30768d45d4f1f643f2f8be53f5d" name="a0e43c30768d45d4f1f643f2f8be53f5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e43c30768d45d4f1f643f2f8be53f5d">&#9670;&#160;</a></span>dot_product()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T comma::dot_product </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the dot product between two vectors. No check on size is performed. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Input type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>First vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Second vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the dot product </dd></dl>

</div>
</div>
<a id="a18179379fcc2bb56e6b89c7b43e249c2" name="a18179379fcc2bb56e6b89c7b43e249c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18179379fcc2bb56e6b89c7b43e249c2">&#9670;&#160;</a></span>fill_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool condition, typename typeA , typename typeB &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void comma::fill_value </td>
          <td>(</td>
          <td class="paramtype">typeA &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typeB &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign from type to another only if a compile-time condition is verified. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">condition</td><td>Boolean telling if the assignment should be done. It has to be a <code>constexpr</code> </td></tr>
    <tr><td class="paramname">typeA</td><td>Type of the destination of the assignment </td></tr>
    <tr><td class="paramname">typeB</td><td>Type of the source of the assignment </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Destination of the assignment </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Source of the assignment </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5193675e5abbdc422bcb8be506e6c08c" name="a5193675e5abbdc422bcb8be506e6c08c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5193675e5abbdc422bcb8be506e6c08c">&#9670;&#160;</a></span>filter_cells_by_n_edges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexT , typename IntT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void comma::filter_cells_by_n_edges </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; IndexT &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; IntT &gt; &amp;&#160;</td>
          <td class="paramname"><em>n_bnd_faces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_set&lt; IntT &gt; &amp;&#160;</td>
          <td class="paramname"><em>allowed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; IndexT &gt; &amp;&#160;</td>
          <td class="paramname"><em>filtered</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given the connectivity of the graph, filter cells keeping only those with the desired number of edges / neighbours. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IndexT</td><td>Type for indices. </td></tr>
    <tr><td class="paramname">IntT</td><td>Type for integers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>Indices of the connectivity of the graph. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_bnd_faces</td><td>Number of boundary faces per cell. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allowed</td><td>Set with the accepted number of edges. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">filtered</td><td>Filtered cells. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3fda6288b7b5c19904abf0312557c774" name="a3fda6288b7b5c19904abf0312557c774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fda6288b7b5c19904abf0312557c774">&#9670;&#160;</a></span>get_direction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T comma::get_direction </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>dir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the direction from point <code>a</code> to point <code>b</code> and store it as unit vector in <code>dir</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Input type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Starting point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>End point </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dir</td><td>Unit vector of the direction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the distance from the two points (the norm used for the normalization) </dd></dl>

</div>
</div>
<a id="aba86840a4cd3b3a35c5e9c7ab417e43b" name="aba86840a4cd3b3a35c5e9c7ab417e43b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba86840a4cd3b3a35c5e9c7ab417e43b">&#9670;&#160;</a></span>int_power()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int p, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T constexpr comma::int_power </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Raise a quantity to an integer power. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">p</td><td>The power </td></tr>
    <tr><td class="paramname">T</td><td>The type of the quantity </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The quantity </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><picture><source srcset="form_28_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ x^p $" src="form_28.png"/></picture> </dd></dl>

</div>
</div>
<a id="a39eb676bbec9475d7b0b5a6186b5f3d0" name="a39eb676bbec9475d7b0b5a6186b5f3d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39eb676bbec9475d7b0b5a6186b5f3d0">&#9670;&#160;</a></span>squared_euclidean_distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T comma::squared_euclidean_distance </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the squared Euclidean distance between two points seen as vectors. We use vectors because we can have both 2- and 3D points (also we can have 3D points even if the dimension given to CoMMA is 2D, e.g., with CODA pseudo-2D meshes). The dimension used as reference is the one of the first point. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type for real numbers </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>First point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Second point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The squared Euclidean distance between the two points </dd></dl>

</div>
</div>
<a id="ab712cf58df5dacc470f08332abdde7ec" name="ab712cf58df5dacc470f08332abdde7ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab712cf58df5dacc470f08332abdde7ec">&#9670;&#160;</a></span>vector_of_first_elements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAContainerPairType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; typename CoMMAContainerPairType::value_type::first_type &gt; comma::vector_of_first_elements </td>
          <td>(</td>
          <td class="paramtype">const CoMMAContainerPairType &amp;&#160;</td>
          <td class="paramname"><em>cont</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a container of pairs, return a vector with first elements only. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CoMMAContainerPairType</td><td>Type of the input container </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cont</td><td>A container of pairs from which the first elements will be extracted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first elements of each pair </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a75164a303f92061683959fa690d67906" name="a75164a303f92061683959fa690d67906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75164a303f92061683959fa690d67906">&#9670;&#160;</a></span>deviate_thresh</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr double comma::deviate_thresh = 0.9396926207859084</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Threshold used in combination with a dot product to tell whether two vector deviate. It is set to <picture><source srcset="form_27_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \cos(20^\circ) $" src="form_27.png"/></picture>. </p>

</div>
</div>
<a id="ae843c64bc9e371bd460fe8d040c80e2b" name="ae843c64bc9e371bd460fe8d040c80e2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae843c64bc9e371bd460fe8d040c80e2b">&#9670;&#160;</a></span>iter_agglo_max_iter</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr CoMMAIntT comma::iter_agglo_max_iter = 4</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum allowed iterations for the iterative algorithm, see <a class="el" href="classcomma_1_1_agglomerator___iterative.html">Agglomerator_Iterative</a>. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacecomma.html">comma</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
