<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CoMMA: comma Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo-CoMMA_70x70.jpg"/></td>
  <td id="projectalign">
   <div id="projectname">CoMMA<span id="projectnumber">&#160;1.3.2</span>
   </div>
   <div id="projectbrief">A geometric agglomerator for unstructured meshes</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespacecomma.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">comma Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_agglomerator.html">Agglomerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class responsible to do the interface between the different kinds of agglomerator.  <a href="classcomma_1_1_agglomerator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_agglomerator___anisotropic.html">Agglomerator_Anisotropic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcomma_1_1_agglomerator___anisotropic.html" title="Agglomerator_Anisotropic class is a child class of the Agglomerator class that specializes the implem...">Agglomerator_Anisotropic</a> class is a child class of the <a class="el" href="classcomma_1_1_agglomerator.html" title="A class responsible to do the interface between the different kinds of agglomerator.">Agglomerator</a> class that specializes the implementation to the case of Anisotropic agglomeration.  <a href="classcomma_1_1_agglomerator___anisotropic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_agglomerator___biconnected.html">Agglomerator_Biconnected</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Child class of <a class="el" href="classcomma_1_1_agglomerator___isotropic.html" title="Agglomerator_Isotropic class is a child class of the Agglomerator class that specializes the implemen...">Agglomerator_Isotropic</a> where is implemented a specific biconnected algorithm for the agglomeration. We call it biconnected case, but it is the greedy algorithm in reality.  <a href="classcomma_1_1_agglomerator___biconnected.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_agglomerator___isotropic.html">Agglomerator_Isotropic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcomma_1_1_agglomerator___isotropic.html" title="Agglomerator_Isotropic class is a child class of the Agglomerator class that specializes the implemen...">Agglomerator_Isotropic</a> class is a child class of the <a class="el" href="classcomma_1_1_agglomerator.html" title="A class responsible to do the interface between the different kinds of agglomerator.">Agglomerator</a> class that specializes the implementation to the case of Isotropic agglomeration.  <a href="classcomma_1_1_agglomerator___isotropic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_agglomerator___iterative.html">Agglomerator_Iterative</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Child class of <a class="el" href="classcomma_1_1_agglomerator___isotropic.html" title="Agglomerator_Isotropic class is a child class of the Agglomerator class that specializes the implemen...">Agglomerator_Isotropic</a> which implements a specialized iterative algorithm for the search of fine cells.  <a href="classcomma_1_1_agglomerator___iterative.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_bimap.html">Bimap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An easy and straight forward implementation of a <a class="el" href="classcomma_1_1_bimap.html" title="An easy and straight forward implementation of a Bimap.">Bimap</a>.  <a href="classcomma_1_1_bimap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_coarse___cell.html">Coarse_Cell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class describing a coarse cell.  <a href="classcomma_1_1_coarse___cell.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_coarse___cell___container.html">Coarse_Cell_Container</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class implementing a custom container where the coarse cells are stored.  <a href="classcomma_1_1_coarse___cell___container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_coarse___cell___subgraph.html">Coarse_Cell_Subgraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class describing a coarse cell with a full description, that is, it also holds a subgraph describing how the fine cells are connected inside the coarse one.  <a href="classcomma_1_1_coarse___cell___subgraph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcomma_1_1_custom_pair_greater_functor.html">CustomPairGreaterFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor for pairs implementing a custom 'greater than'. It relies on the 'greater than' operator for the second elements and 'less than' for the first ones.  <a href="structcomma_1_1_custom_pair_greater_functor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcomma_1_1_custom_pair_less_functor.html">CustomPairLessFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor for pairs implementing a custom 'less than'. It relies on the 'less than' operator for the second elements and 'greater than' for the first ones.  <a href="structcomma_1_1_custom_pair_less_functor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_dual___graph.html">Dual_Graph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class implementing the CRS global graph representation of the global mesh.  <a href="classcomma_1_1_dual___graph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_graph.html">Graph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An interface class responsible of storing the cell centered dual graph and of acting on it (it is an interface for the global <a class="el" href="classcomma_1_1_dual___graph.html" title="A class implementing the CRS global graph representation of the global mesh.">Dual_Graph</a> and the <a class="el" href="classcomma_1_1_subgraph.html" title="A class implementing the CRS subgraph representation. It is used in the framework of CoMMA for the im...">Subgraph</a>)  <a href="classcomma_1_1_graph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_neighbourhood.html">Neighbourhood</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing the neighbourhood of a given cell in the graph. Mind that no information about the element being already agglomerated or not is known here.  <a href="classcomma_1_1_neighbourhood.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_neighbourhood___extended.html">Neighbourhood_Extended</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing the neighbourhood of a given cell in the graph. In this derived class the neighbourhood is extended, meaning that all the neighbours seen so far are candidates.  <a href="classcomma_1_1_neighbourhood___extended.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_neighbourhood___pure___front.html">Neighbourhood_Pure_Front</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing the neighbourhood of a given cell in the graph. In this derived class, the neighbourhood is 'pure front-advancing', meaning that the next candidates are only the direct neighbours of the last added cell.  <a href="classcomma_1_1_neighbourhood___pure___front.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_neighbourhood_creator.html">NeighbourhoodCreator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pure abstract class for a creator of <a class="el" href="classcomma_1_1_neighbourhood.html" title="Class representing the neighbourhood of a given cell in the graph. Mind that no information about the...">Neighbourhood</a> objects. It can create from scratch or by copy.  <a href="classcomma_1_1_neighbourhood_creator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_neighbourhood_extended_creator.html">NeighbourhoodExtendedCreator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creator of <a class="el" href="classcomma_1_1_neighbourhood___extended.html" title="Class representing the neighbourhood of a given cell in the graph. In this derived class the neighbou...">Neighbourhood_Extended</a> objects. It can create from scratch or by copy.  <a href="classcomma_1_1_neighbourhood_extended_creator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_neighbourhood_pure_front_creator.html">NeighbourhoodPureFrontCreator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creator of <a class="el" href="classcomma_1_1_neighbourhood___extended.html" title="Class representing the neighbourhood of a given cell in the graph. In this derived class the neighbou...">Neighbourhood_Extended</a> objects. It can create from scratch or by copy.  <a href="classcomma_1_1_neighbourhood_pure_front_creator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_node.html">Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcomma_1_1_node.html" title="Node data structure that represent a node of the tree.">Node</a> data structure that represent a node of the tree.  <a href="classcomma_1_1_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_pair_find_first_based_functor.html">PairFindFirstBasedFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor implementing an operator telling if a given value if the first one of pair.  <a href="classcomma_1_1_pair_find_first_based_functor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcomma_1_1_pair_second_based_less_functor.html">PairSecondBasedLessFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor for pairs implementing a less operator based only on the second element of the pair.  <a href="structcomma_1_1_pair_second_based_less_functor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_priority___pair.html">Priority_Pair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around the STL pair with custom 'less than' operator: as in the standard case, first we compare the first elements, then the second ones; however it relies on the 'greater than' on the first elements, e.g., (4,X) &lt; (3,Y), whereas standard rules apply to second elements, e.g., (4,3) &lt; (4,4).  <a href="classcomma_1_1_priority___pair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_queue.html">Queue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template class implementing a custom queue data structure.  <a href="classcomma_1_1_queue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_seeds___pool.html">Seeds_Pool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing the pool of all the seeds for creating a coarse cell.  <a href="classcomma_1_1_seeds___pool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_seeds___pool___boundary___priority.html">Seeds_Pool_Boundary_Priority</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing the pool of all the seeds for creating a coarse cell. This derived class gives higher priority to cells that are on the border.  <a href="classcomma_1_1_seeds___pool___boundary___priority.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_seeds___pool___neighbourhood___priority.html">Seeds_Pool_Neighbourhood_Priority</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing the pool of all the seeds for creating a coarse cell. This derived class gives higher priority to cells that are neighbours of already existing coarse cells.  <a href="classcomma_1_1_seeds___pool___neighbourhood___priority.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcomma_1_1_s_p_full_initializator.html">SPFullInitializator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor performing the full initialization of a seeds pool.  <a href="structcomma_1_1_s_p_full_initializator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcomma_1_1_s_p_initializator.html">SPInitializator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor performing the initialization of a seeds pool.  <a href="structcomma_1_1_s_p_initializator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcomma_1_1_s_p_one_point_initializator.html">SPOnePointInitializator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor performing the one-point initialization of a seeds pool.  <a href="structcomma_1_1_s_p_one_point_initializator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_subgraph.html">Subgraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class implementing the CRS subgraph representation. It is used in the framework of CoMMA for the implementation of the CSR representation of the coarse cells.  <a href="classcomma_1_1_subgraph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_tree.html">Tree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcomma_1_1_tree.html" title="Tree structure that represent a coarse cell, the fine cell and the neighbours to them.">Tree</a> structure that represent a coarse cell, the fine cell and the neighbours to them.  <a href="classcomma_1_1_tree.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a6676cd5a4d3dbf9141f8c7bc87617be8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecomma.html#a6676cd5a4d3dbf9141f8c7bc87617be8">CoMMACellT</a> : CoMMAIntT { <br />
&#160;&#160;<a class="el" href="namespacecomma.html#a6676cd5a4d3dbf9141f8c7bc87617be8ada6f7a085b1f7f2125ce30f5e02db53c">INTERIOR</a> = 0
, <a class="el" href="namespacecomma.html#a6676cd5a4d3dbf9141f8c7bc87617be8a4f18a70072d52370244908b93cf13e85">VALLEY</a> = 1
, <a class="el" href="namespacecomma.html#a6676cd5a4d3dbf9141f8c7bc87617be8aaa4cdfbb2d1efc15da1728bbc125e9f1">RIDGE</a> = 2
, <a class="el" href="namespacecomma.html#a6676cd5a4d3dbf9141f8c7bc87617be8a39ad49623cc576b66fc391bd2bc1c7cf">CORNER</a> = 3
, <br />
&#160;&#160;<a class="el" href="namespacecomma.html#a6676cd5a4d3dbf9141f8c7bc87617be8ac5e925f6e54a010df01d51f9b4e6f981">EXTREME</a> = 4
, <a class="el" href="namespacecomma.html#a6676cd5a4d3dbf9141f8c7bc87617be8a0309283de9cefb87968e32825c3418ec">N_CELL_TYPES</a> = 4
<br />
 }</td></tr>
<tr class="memdesc:a6676cd5a4d3dbf9141f8c7bc87617be8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of an element according to its boundary faces / edges The terms come from the NIA paper: Nishikawa, Diskin, Thomas...  <a href="namespacecomma.html#a6676cd5a4d3dbf9141f8c7bc87617be8">More...</a><br /></td></tr>
<tr class="separator:a6676cd5a4d3dbf9141f8c7bc87617be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a705b45ec112a3ac1bf59f760f0f4d022"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecomma.html#a705b45ec112a3ac1bf59f760f0f4d022">CoMMANeighbourhoodT</a> : CoMMAIntT { <a class="el" href="namespacecomma.html#a705b45ec112a3ac1bf59f760f0f4d022a5b91bee96d92adb448b6529d2ea8289d">EXTENDED</a> = 0
, <a class="el" href="namespacecomma.html#a705b45ec112a3ac1bf59f760f0f4d022a681aa75b2dff7410008df1396b15fe35">PURE_FRONT</a> = 1
 }</td></tr>
<tr class="memdesc:a705b45ec112a3ac1bf59f760f0f4d022"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of neighbourhood (of a coarse cell) considered when agglomerating.  <a href="namespacecomma.html#a705b45ec112a3ac1bf59f760f0f4d022">More...</a><br /></td></tr>
<tr class="separator:a705b45ec112a3ac1bf59f760f0f4d022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c8213401033616d834d48d77bf359a4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecomma.html#a8c8213401033616d834d48d77bf359a4">CoMMASeedsPoolT</a> : CoMMAIntT { <a class="el" href="namespacecomma.html#a8c8213401033616d834d48d77bf359a4a7340b7195c9071cd34c7d9a633a3d857">BOUNDARY_PRIORITY</a> = 0
, <a class="el" href="namespacecomma.html#a8c8213401033616d834d48d77bf359a4ae3fbc583bddef8540a06125ed1e7dc79">NEIGHBOURHOOD_PRIORITY</a> = 1
, <a class="el" href="namespacecomma.html#a8c8213401033616d834d48d77bf359a4a29ddaed9cc8cda952d02296b79010787">BOUNDARY_PRIORITY_ONE_POINT_INIT</a> = 10
, <a class="el" href="namespacecomma.html#a8c8213401033616d834d48d77bf359a4a8c23e18158e720cbd348f98e50376a5d">NEIGHBOURHOOD_PRIORITY_ONE_POINT_INIT</a> = 11
 }</td></tr>
<tr class="memdesc:a8c8213401033616d834d48d77bf359a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of seeds pool ordering.  <a href="namespacecomma.html#a8c8213401033616d834d48d77bf359a4">More...</a><br /></td></tr>
<tr class="separator:a8c8213401033616d834d48d77bf359a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2d9288bb16f6c211415b0458dafb18a4"><td class="memTemplParams" colspan="2">template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </td></tr>
<tr class="memitem:a2d9288bb16f6c211415b0458dafb18a4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomma.html#a2d9288bb16f6c211415b0458dafb18a4">agglomerate_one_level</a> (const std::vector&lt; CoMMAIndexType &gt; &amp;adjMatrix_row_ptr, const std::vector&lt; CoMMAIndexType &gt; &amp;adjMatrix_col_ind, const std::vector&lt; CoMMAWeightType &gt; &amp;adjMatrix_areaValues, const std::vector&lt; CoMMAWeightType &gt; &amp;volumes, const std::vector&lt; std::vector&lt; CoMMAWeightType &gt; &gt; &amp;centers, const std::vector&lt; CoMMAWeightType &gt; &amp;priority_weights, const std::vector&lt; CoMMAIndexType &gt; &amp;anisotropicCompliantCells, const std::vector&lt; CoMMAIntType &gt; &amp;n_bnd_faces, bool build_anisotropic_lines, bool is_anisotropic, bool odd_line_length, CoMMAWeightType threshold_anisotropy, const CoMMAIntType seed_ordering_type, std::vector&lt; CoMMAIndexType &gt; &amp;fc_to_cc, std::vector&lt; CoMMAIndexType &gt; &amp;agglomerationLines_Idx, std::vector&lt; CoMMAIndexType &gt; &amp;agglomerationLines, bool correction, CoMMAIntType dimension, CoMMAIntType goal_card, CoMMAIntType min_card, CoMMAIntType max_card, CoMMAIntType singular_card_thresh=1, std::optional&lt; CoMMAIndexType &gt; max_cells_in_line=std::nullopt, CoMMAIntType fc_choice_iter=1, const CoMMAIntType neighbourhood_type=<a class="el" href="namespacecomma.html#a705b45ec112a3ac1bf59f760f0f4d022a5b91bee96d92adb448b6529d2ea8289d">CoMMANeighbourhoodT::EXTENDED</a>)</td></tr>
<tr class="memdesc:a2d9288bb16f6c211415b0458dafb18a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main function of the agglomerator, it is used as an interface to build up all the agglomeration process. The result will be the definition of the agglomerated cells <code>fc_to_cc</code>.  <a href="namespacecomma.html#a2d9288bb16f6c211415b0458dafb18a4">More...</a><br /></td></tr>
<tr class="separator:a2d9288bb16f6c211415b0458dafb18a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18179379fcc2bb56e6b89c7b43e249c2"><td class="memTemplParams" colspan="2">template&lt;bool condition, typename typeA , typename typeB &gt; </td></tr>
<tr class="memitem:a18179379fcc2bb56e6b89c7b43e249c2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomma.html#a18179379fcc2bb56e6b89c7b43e249c2">fill_value</a> (typeA &amp;a, typeB &amp;b)</td></tr>
<tr class="memdesc:a18179379fcc2bb56e6b89c7b43e249c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign from type to another only if a compile-time condition is verified.  <a href="namespacecomma.html#a18179379fcc2bb56e6b89c7b43e249c2">More...</a><br /></td></tr>
<tr class="separator:a18179379fcc2bb56e6b89c7b43e249c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6823809d0c8cc7a1e30d51cfb0ce21a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa6823809d0c8cc7a1e30d51cfb0ce21a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomma.html#aa6823809d0c8cc7a1e30d51cfb0ce21a">dot_deviate</a> (const T dot)</td></tr>
<tr class="memdesc:aa6823809d0c8cc7a1e30d51cfb0ce21a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell whether the dot product given as input comes from two parallel vectors. Compared against <a class="el" href="namespacecomma.html#a75164a303f92061683959fa690d67906">deviate_thresh</a>.  <a href="namespacecomma.html#aa6823809d0c8cc7a1e30d51cfb0ce21a">More...</a><br /></td></tr>
<tr class="separator:aa6823809d0c8cc7a1e30d51cfb0ce21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e43c30768d45d4f1f643f2f8be53f5d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0e43c30768d45d4f1f643f2f8be53f5d"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomma.html#a0e43c30768d45d4f1f643f2f8be53f5d">dot_product</a> (const std::vector&lt; T &gt; &amp;a, const std::vector&lt; T &gt; &amp;b)</td></tr>
<tr class="memdesc:a0e43c30768d45d4f1f643f2f8be53f5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the dot product between two vectors. No check on size is performed.  <a href="namespacecomma.html#a0e43c30768d45d4f1f643f2f8be53f5d">More...</a><br /></td></tr>
<tr class="separator:a0e43c30768d45d4f1f643f2f8be53f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fda6288b7b5c19904abf0312557c774"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3fda6288b7b5c19904abf0312557c774"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomma.html#a3fda6288b7b5c19904abf0312557c774">get_direction</a> (const std::vector&lt; T &gt; &amp;a, const std::vector&lt; T &gt; &amp;b, std::vector&lt; T &gt; &amp;dir)</td></tr>
<tr class="memdesc:a3fda6288b7b5c19904abf0312557c774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the direction from point <code>a</code> to point <code>b</code> and store it as unit vector in <code>dir</code>.  <a href="namespacecomma.html#a3fda6288b7b5c19904abf0312557c774">More...</a><br /></td></tr>
<tr class="separator:a3fda6288b7b5c19904abf0312557c774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39eb676bbec9475d7b0b5a6186b5f3d0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a39eb676bbec9475d7b0b5a6186b5f3d0"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomma.html#a39eb676bbec9475d7b0b5a6186b5f3d0">squared_euclidean_distance</a> (const std::vector&lt; T &gt; &amp;a, const std::vector&lt; T &gt; &amp;b)</td></tr>
<tr class="memdesc:a39eb676bbec9475d7b0b5a6186b5f3d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the squared Euclidean distance between two points seen as vectors. We use vectors because we can have both 2- and 3D points (also we can have 3D points even if the dimension given to CoMMA is 2D, e.g., with CODA pseudo-2D meshes). The dimension used as reference is the one of the first point.  <a href="namespacecomma.html#a39eb676bbec9475d7b0b5a6186b5f3d0">More...</a><br /></td></tr>
<tr class="separator:a39eb676bbec9475d7b0b5a6186b5f3d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab712cf58df5dacc470f08332abdde7ec"><td class="memTemplParams" colspan="2">template&lt;typename CoMMAContainerPairType &gt; </td></tr>
<tr class="memitem:ab712cf58df5dacc470f08332abdde7ec"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename CoMMAContainerPairType::value_type::first_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomma.html#ab712cf58df5dacc470f08332abdde7ec">vector_of_first_elements</a> (const CoMMAContainerPairType &amp;cont)</td></tr>
<tr class="memdesc:ab712cf58df5dacc470f08332abdde7ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a container of pairs, return a vector with first elements only.  <a href="namespacecomma.html#ab712cf58df5dacc470f08332abdde7ec">More...</a><br /></td></tr>
<tr class="separator:ab712cf58df5dacc470f08332abdde7ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81affca718f9c9927cfb82c317c8239e"><td class="memTemplParams" colspan="2">template&lt;typename KeyT , typename ValueT &gt; </td></tr>
<tr class="memitem:a81affca718f9c9927cfb82c317c8239e"><td class="memTemplItemLeft" align="right" valign="top">std::unordered_set&lt; KeyT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomma.html#a81affca718f9c9927cfb82c317c8239e">d_keys_to_set</a> (const std::unordered_map&lt; KeyT, ValueT &gt; &amp;dict)</td></tr>
<tr class="memdesc:a81affca718f9c9927cfb82c317c8239e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function for creating a set out of the keys of a map.  <a href="namespacecomma.html#a81affca718f9c9927cfb82c317c8239e">More...</a><br /></td></tr>
<tr class="separator:a81affca718f9c9927cfb82c317c8239e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3653181db03b3ea76722462c3b3e02b"><td class="memTemplParams" colspan="2">template&lt;typename IndexT , typename DistT &gt; </td></tr>
<tr class="memitem:ae3653181db03b3ea76722462c3b3e02b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomma.html#ae3653181db03b3ea76722462c3b3e02b">compute_neighbourhood_based_wall_distance</a> (const std::vector&lt; IndexT &gt; &amp;neigh_idxs, const std::vector&lt; IndexT &gt; &amp;neighs, const std::vector&lt; IndexT &gt; &amp;wall, std::vector&lt; DistT &gt; &amp;dist)</td></tr>
<tr class="memdesc:ae3653181db03b3ea76722462c3b3e02b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a neighbourhood-base wall-distance, that is, the distance of a given cell from a wall is the number of cells though which the minimum path starting from the cell and ending at the wall. For example, in a Cartesian grids this is equivalent to the minimum of the Manhattan distance.<br  />
 If the vector defining the wall is empty, return negative values.<br  />
 If a cell is unconnected to the domain with the wall, its distance will be negative.<br  />
 It takes a compressed version of the connectivity of the mesh. It uses a BFS algorithm to visit all the cells.  <a href="namespacecomma.html#ae3653181db03b3ea76722462c3b3e02b">More...</a><br /></td></tr>
<tr class="separator:ae3653181db03b3ea76722462c3b3e02b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ae843c64bc9e371bd460fe8d040c80e2b"><td class="memItemLeft" align="right" valign="top">constexpr CoMMAIntT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecomma.html#ae843c64bc9e371bd460fe8d040c80e2b">iter_agglo_max_iter</a> = 4</td></tr>
<tr class="memdesc:ae843c64bc9e371bd460fe8d040c80e2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum allowed iterations for the iterative algorithm, see <a class="el" href="classcomma_1_1_agglomerator___iterative.html">Agglomerator_Iterative</a>.  <a href="namespacecomma.html#ae843c64bc9e371bd460fe8d040c80e2b">More...</a><br /></td></tr>
<tr class="separator:ae843c64bc9e371bd460fe8d040c80e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75164a303f92061683959fa690d67906"><td class="memItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecomma.html#a75164a303f92061683959fa690d67906">deviate_thresh</a> = 0.9396926207859084</td></tr>
<tr class="memdesc:a75164a303f92061683959fa690d67906"><td class="mdescLeft">&#160;</td><td class="mdescRight">Threshold used in combination with a dot product to tell whether two vector deviate. It is set to <picture><source srcset="form_4_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \cos(20^\circ) $" src="form_4.png"/></picture>.  <a href="namespacecomma.html#a75164a303f92061683959fa690d67906">More...</a><br /></td></tr>
<tr class="separator:a75164a303f92061683959fa690d67906"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a6676cd5a4d3dbf9141f8c7bc87617be8" name="a6676cd5a4d3dbf9141f8c7bc87617be8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6676cd5a4d3dbf9141f8c7bc87617be8">&#9670;&#160;</a></span>CoMMACellT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacecomma.html#a6676cd5a4d3dbf9141f8c7bc87617be8">comma::CoMMACellT</a> : CoMMAIntT</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of an element according to its boundary faces / edges The terms come from the NIA paper: Nishikawa, Diskin, Thomas... </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6676cd5a4d3dbf9141f8c7bc87617be8ada6f7a085b1f7f2125ce30f5e02db53c" name="a6676cd5a4d3dbf9141f8c7bc87617be8ada6f7a085b1f7f2125ce30f5e02db53c"></a>INTERIOR&#160;</td><td class="fielddoc"><p >Interior cell, no boundary faces. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6676cd5a4d3dbf9141f8c7bc87617be8a4f18a70072d52370244908b93cf13e85" name="a6676cd5a4d3dbf9141f8c7bc87617be8a4f18a70072d52370244908b93cf13e85"></a>VALLEY&#160;</td><td class="fielddoc"><p >Valley, one boundary face. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6676cd5a4d3dbf9141f8c7bc87617be8aaa4cdfbb2d1efc15da1728bbc125e9f1" name="a6676cd5a4d3dbf9141f8c7bc87617be8aaa4cdfbb2d1efc15da1728bbc125e9f1"></a>RIDGE&#160;</td><td class="fielddoc"><p >Ridge, two boundary faces. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6676cd5a4d3dbf9141f8c7bc87617be8a39ad49623cc576b66fc391bd2bc1c7cf" name="a6676cd5a4d3dbf9141f8c7bc87617be8a39ad49623cc576b66fc391bd2bc1c7cf"></a>CORNER&#160;</td><td class="fielddoc"><p >Corners, three boundary faces. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6676cd5a4d3dbf9141f8c7bc87617be8ac5e925f6e54a010df01d51f9b4e6f981" name="a6676cd5a4d3dbf9141f8c7bc87617be8ac5e925f6e54a010df01d51f9b4e6f981"></a>EXTREME&#160;</td><td class="fielddoc"><p >Extreme value, should not be used. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6676cd5a4d3dbf9141f8c7bc87617be8a0309283de9cefb87968e32825c3418ec" name="a6676cd5a4d3dbf9141f8c7bc87617be8a0309283de9cefb87968e32825c3418ec"></a>N_CELL_TYPES&#160;</td><td class="fielddoc"><p >Total number of values. </p>
</td></tr>
</table>

</div>
</div>
<a id="a705b45ec112a3ac1bf59f760f0f4d022" name="a705b45ec112a3ac1bf59f760f0f4d022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a705b45ec112a3ac1bf59f760f0f4d022">&#9670;&#160;</a></span>CoMMANeighbourhoodT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacecomma.html#a705b45ec112a3ac1bf59f760f0f4d022">comma::CoMMANeighbourhoodT</a> : CoMMAIntT</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of neighbourhood (of a coarse cell) considered when agglomerating. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a705b45ec112a3ac1bf59f760f0f4d022a5b91bee96d92adb448b6529d2ea8289d" name="a705b45ec112a3ac1bf59f760f0f4d022a5b91bee96d92adb448b6529d2ea8289d"></a>EXTENDED&#160;</td><td class="fielddoc"><p >Extended, all neighbours of the coarse cell. </p>
</td></tr>
<tr><td class="fieldname"><a id="a705b45ec112a3ac1bf59f760f0f4d022a681aa75b2dff7410008df1396b15fe35" name="a705b45ec112a3ac1bf59f760f0f4d022a681aa75b2dff7410008df1396b15fe35"></a>PURE_FRONT&#160;</td><td class="fielddoc"><p >Pure front, only neighbours of the last added fine cell. </p>
</td></tr>
</table>

</div>
</div>
<a id="a8c8213401033616d834d48d77bf359a4" name="a8c8213401033616d834d48d77bf359a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c8213401033616d834d48d77bf359a4">&#9670;&#160;</a></span>CoMMASeedsPoolT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacecomma.html#a8c8213401033616d834d48d77bf359a4">comma::CoMMASeedsPoolT</a> : CoMMAIntT</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of seeds pool ordering. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8c8213401033616d834d48d77bf359a4a7340b7195c9071cd34c7d9a633a3d857" name="a8c8213401033616d834d48d77bf359a4a7340b7195c9071cd34c7d9a633a3d857"></a>BOUNDARY_PRIORITY&#160;</td><td class="fielddoc"><p >The number of boundary faces has highest priority </p>
</td></tr>
<tr><td class="fieldname"><a id="a8c8213401033616d834d48d77bf359a4ae3fbc583bddef8540a06125ed1e7dc79" name="a8c8213401033616d834d48d77bf359a4ae3fbc583bddef8540a06125ed1e7dc79"></a>NEIGHBOURHOOD_PRIORITY&#160;</td><td class="fielddoc"><p >The neighbourhood has highest priority (neighbours of coarse cells have priority) </p>
</td></tr>
<tr><td class="fieldname"><a id="a8c8213401033616d834d48d77bf359a4a29ddaed9cc8cda952d02296b79010787" name="a8c8213401033616d834d48d77bf359a4a29ddaed9cc8cda952d02296b79010787"></a>BOUNDARY_PRIORITY_ONE_POINT_INIT&#160;</td><td class="fielddoc"><p >The number of boundary faces has highest priority, and initialize with one point only then let evolve </p>
</td></tr>
<tr><td class="fieldname"><a id="a8c8213401033616d834d48d77bf359a4a8c23e18158e720cbd348f98e50376a5d" name="a8c8213401033616d834d48d77bf359a4a8c23e18158e720cbd348f98e50376a5d"></a>NEIGHBOURHOOD_PRIORITY_ONE_POINT_INIT&#160;</td><td class="fielddoc"><p >The neighbourhood has highest priority, and initialize with one point only then let evolve </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a2d9288bb16f6c211415b0458dafb18a4" name="a2d9288bb16f6c211415b0458dafb18a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d9288bb16f6c211415b0458dafb18a4">&#9670;&#160;</a></span>agglomerate_one_level()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void comma::agglomerate_one_level </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; CoMMAIndexType &gt; &amp;&#160;</td>
          <td class="paramname"><em>adjMatrix_row_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; CoMMAIndexType &gt; &amp;&#160;</td>
          <td class="paramname"><em>adjMatrix_col_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; CoMMAWeightType &gt; &amp;&#160;</td>
          <td class="paramname"><em>adjMatrix_areaValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; CoMMAWeightType &gt; &amp;&#160;</td>
          <td class="paramname"><em>volumes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; CoMMAWeightType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>centers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; CoMMAWeightType &gt; &amp;&#160;</td>
          <td class="paramname"><em>priority_weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; CoMMAIndexType &gt; &amp;&#160;</td>
          <td class="paramname"><em>anisotropicCompliantCells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; CoMMAIntType &gt; &amp;&#160;</td>
          <td class="paramname"><em>n_bnd_faces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>build_anisotropic_lines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_anisotropic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>odd_line_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoMMAWeightType&#160;</td>
          <td class="paramname"><em>threshold_anisotropy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CoMMAIntType&#160;</td>
          <td class="paramname"><em>seed_ordering_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; CoMMAIndexType &gt; &amp;&#160;</td>
          <td class="paramname"><em>fc_to_cc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; CoMMAIndexType &gt; &amp;&#160;</td>
          <td class="paramname"><em>agglomerationLines_Idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; CoMMAIndexType &gt; &amp;&#160;</td>
          <td class="paramname"><em>agglomerationLines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>correction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoMMAIntType&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoMMAIntType&#160;</td>
          <td class="paramname"><em>goal_card</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoMMAIntType&#160;</td>
          <td class="paramname"><em>min_card</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoMMAIntType&#160;</td>
          <td class="paramname"><em>max_card</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoMMAIntType&#160;</td>
          <td class="paramname"><em>singular_card_thresh</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; CoMMAIndexType &gt;&#160;</td>
          <td class="paramname"><em>max_cells_in_line</em> = <code>std::nullopt</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoMMAIntType&#160;</td>
          <td class="paramname"><em>fc_choice_iter</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CoMMAIntType&#160;</td>
          <td class="paramname"><em>neighbourhood_type</em> = <code><a class="el" href="namespacecomma.html#a705b45ec112a3ac1bf59f760f0f4d022a5b91bee96d92adb448b6529d2ea8289d">CoMMANeighbourhoodT::EXTENDED</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Main function of the agglomerator, it is used as an interface to build up all the agglomeration process. The result will be the definition of the agglomerated cells <code>fc_to_cc</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CoMMAIndexType</td><td>the CoMMA index type for the global index of the mesh </td></tr>
    <tr><td class="paramname">CoMMAWeightType</td><td>the CoMMA weight type for the weights (volume or area) of the nodes or edges of the Mesh </td></tr>
    <tr><td class="paramname">CoMMAIntType</td><td>the CoMMA type for integers </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">adjMatrix_row_ptr</td><td>the row pointer of the CRS representation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">adjMatrix_col_ind</td><td>the column index of the CRS representation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">adjMatrix_areaValues</td><td>the weight of the CRS representation (in CoMMA case will be the area of the faces that in the graph representation are the edges between two nodes represented by the cell centers. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">volumes</td><td>The volumes of the cells </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">centers</td><td>Cell centers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">priority_weights</td><td>Weights used to set the order telling where to start agglomerating. The higher the weight, the higher the priority </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">anisotropicCompliantCells</td><td>List of cells which have to be looked for anisotropy </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_bnd_faces</td><td>Vector telling how many boundary faces each cell has </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">build_anisotropic_lines</td><td>Whether lines joining the anisotropic cells should be built, otherwise, if the anisotropic agglomeration is activated, the lines should be provided, see <code>agglomerationLines_Idx</code> and <code>agglomerationLines</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_anisotropic</td><td>Whether to consider an anisotropic agglomeration </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">odd_line_length</td><td>Whether anisotropic lines with odd length are allowed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">threshold_anisotropy</td><td>Value of the aspect-ratio above which a cell is considered as anisotropic. If negative, all compliant cells are considered as anisotropic </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seed_ordering_type</td><td>Type of ordering for the seeds of the coarse cells. Possible values (see <a class="el" href="namespacecomma.html#a8c8213401033616d834d48d77bf359a4">CoMMASeedsPoolT</a>):<ul>
<li>0: The number of boundary faces has highest priority</li>
<li>1: The neighbourhood has highest priority (neighbours of coarse cells have priority)</li>
<li>10: The number of boundary faces has highest priority, and initialize with one point only then let evolve</li>
<li>11: The neighbourhood has highest priority, and initialize with one point only then let evolve </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fc_to_cc</td><td>Vector telling the ID of the coarse cell to which a fine cell belongs after agglomeration </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">agglomerationLines_Idx</td><td>Connectivity for the agglomeration lines: each element points to a particular element in the vector <code>agglomerationLines</code> </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">agglomerationLines</td><td>Vector storing all the elements of the anisotropic lines </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">correction</td><td>Whether to apply correction step (avoid isolated cells) after agglomeration </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dimension</td><td>Dimensionality of the problem, 2- or 3D </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">goal_card</td><td>Expected cardinality of the coarse cells (might not be ensured) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_card</td><td>Minimum cardinality accepted for the coarse cells </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_card</td><td>Maximum cardinality accepted for the coarse cells </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">singular_card_thresh</td><td>(optional, default=1) Cardinality below which a coarse is considered as singular, hence, compliant for correction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_cells_in_line</td><td>[Optional] Maximum number of cells in an anisotropic line; when this value is reached, all reaming cells are discarded, hence considered as isotropic </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fc_choice_iter</td><td>(optional, default=1) Number of iterations allowed for the algorithm choosing which fine cell to add next. The cost grows exponentially, hence use small values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">neighbourhood_type</td><td>(optional, default=Extended) Type of neighbourhood to use when growing a coarse cell. See <a class="el" href="namespacecomma.html#a705b45ec112a3ac1bf59f760f0f4d022">CoMMANeighbourhoodT</a> for more details. Two alternatives:<ul>
<li>Extended: requested with 0, standard algorithm where we consider every neighbour of the coarse cell as candidate.</li>
<li>Pure Front Advancing: requested with 1, only direct neighbours of the last added cell are candidates. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">invalid_argument</td><td>whenever dimension is not 2 nor 3, cardinalities are smaller than 1 or not in order, line building is disabled but lines are not provided, or number of iterations is negative or greater than <a class="el" href="namespacecomma.html#ae843c64bc9e371bd460fe8d040c80e2b">iter_agglo_max_iter</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section copyright"><dt>Copyright</dt><dd>Copyright © 2024 ONERA </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Nicolas Lantos, Alberto Remigi, and Riccardo Milani </dd></dl>
<dl class="section user"><dt>Contributor</dt><dd>Karim Anemiche </dd></dl>
<dl class="section user"><dt>License</dt><dd>This project is released under the Mozilla Public License 2.0, see <a href="https://mozilla.org/MPL/2.0/">https://mozilla.org/MPL/2.0/</a> </dd></dl>

</div>
</div>
<a id="ae3653181db03b3ea76722462c3b3e02b" name="ae3653181db03b3ea76722462c3b3e02b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3653181db03b3ea76722462c3b3e02b">&#9670;&#160;</a></span>compute_neighbourhood_based_wall_distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexT , typename DistT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void comma::compute_neighbourhood_based_wall_distance </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; IndexT &gt; &amp;&#160;</td>
          <td class="paramname"><em>neigh_idxs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; IndexT &gt; &amp;&#160;</td>
          <td class="paramname"><em>neighs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; IndexT &gt; &amp;&#160;</td>
          <td class="paramname"><em>wall</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; DistT &gt; &amp;&#160;</td>
          <td class="paramname"><em>dist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a neighbourhood-base wall-distance, that is, the distance of a given cell from a wall is the number of cells though which the minimum path starting from the cell and ending at the wall. For example, in a Cartesian grids this is equivalent to the minimum of the Manhattan distance.<br  />
 If the vector defining the wall is empty, return negative values.<br  />
 If a cell is unconnected to the domain with the wall, its distance will be negative.<br  />
 It takes a compressed version of the connectivity of the mesh. It uses a BFS algorithm to visit all the cells. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IndexT</td><td>Type for cell indices </td></tr>
    <tr><td class="paramname">DistT</td><td>Type for distance (should be signed) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">neigh_idxs</td><td>Indices used to recover the neighbours of each cells provided in <code>neighs</code>. The length is <picture><source srcset="form_5_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ N_{cells} + 1 $" src="form_5.png"/></picture> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">neighs</td><td>Neighbours of the cells </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wall</td><td>Cells composing the wall from which the distance is computed </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dist</td><td>Distance from the wall. This vector is resized inside the function to hold all the cells </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is <b>experimental</b>. Moreover, since CoMMA has knowledge of the current domain only, this function might not give the right result if the domain has been partitioned. It is advised to use this function only when considering one domain only. </dd></dl>

</div>
</div>
<a id="a81affca718f9c9927cfb82c317c8239e" name="a81affca718f9c9927cfb82c317c8239e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81affca718f9c9927cfb82c317c8239e">&#9670;&#160;</a></span>d_keys_to_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT , typename ValueT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_set&lt; KeyT &gt; comma::d_keys_to_set </td>
          <td>(</td>
          <td class="paramtype">const std::unordered_map&lt; KeyT, ValueT &gt; &amp;&#160;</td>
          <td class="paramname"><em>dict</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function for creating a set out of the keys of a map. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyT</td><td>Type of the keys of the map </td></tr>
    <tr><td class="paramname">ValueT</td><td>Type of the values of the map </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dict</td><td>A map </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a set </dd></dl>

</div>
</div>
<a id="aa6823809d0c8cc7a1e30d51cfb0ce21a" name="aa6823809d0c8cc7a1e30d51cfb0ce21a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6823809d0c8cc7a1e30d51cfb0ce21a">&#9670;&#160;</a></span>dot_deviate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool comma::dot_deviate </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>dot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tell whether the dot product given as input comes from two parallel vectors. Compared against <a class="el" href="namespacecomma.html#a75164a303f92061683959fa690d67906">deviate_thresh</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Input type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dot</td><td>Dot product </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if higher than a reference threshold </dd></dl>

</div>
</div>
<a id="a0e43c30768d45d4f1f643f2f8be53f5d" name="a0e43c30768d45d4f1f643f2f8be53f5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e43c30768d45d4f1f643f2f8be53f5d">&#9670;&#160;</a></span>dot_product()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T comma::dot_product </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the dot product between two vectors. No check on size is performed. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Input type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>First vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Second vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the dot product </dd></dl>

</div>
</div>
<a id="a18179379fcc2bb56e6b89c7b43e249c2" name="a18179379fcc2bb56e6b89c7b43e249c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18179379fcc2bb56e6b89c7b43e249c2">&#9670;&#160;</a></span>fill_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool condition, typename typeA , typename typeB &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void comma::fill_value </td>
          <td>(</td>
          <td class="paramtype">typeA &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typeB &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign from type to another only if a compile-time condition is verified. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">condition</td><td>Boolean telling if the assignment should be done. It has to be a <code>constexpr</code> </td></tr>
    <tr><td class="paramname">typeA</td><td>Type of the destination of the assignment </td></tr>
    <tr><td class="paramname">typeB</td><td>Type of the source of the assignment </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Destination of the assignment </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Source of the assignment </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3fda6288b7b5c19904abf0312557c774" name="a3fda6288b7b5c19904abf0312557c774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fda6288b7b5c19904abf0312557c774">&#9670;&#160;</a></span>get_direction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T comma::get_direction </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>dir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the direction from point <code>a</code> to point <code>b</code> and store it as unit vector in <code>dir</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Input type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Starting point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>End point </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dir</td><td>Unit vector of the direction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the distance from the two points (the norm used for the normalization) </dd></dl>

</div>
</div>
<a id="a39eb676bbec9475d7b0b5a6186b5f3d0" name="a39eb676bbec9475d7b0b5a6186b5f3d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39eb676bbec9475d7b0b5a6186b5f3d0">&#9670;&#160;</a></span>squared_euclidean_distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T comma::squared_euclidean_distance </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the squared Euclidean distance between two points seen as vectors. We use vectors because we can have both 2- and 3D points (also we can have 3D points even if the dimension given to CoMMA is 2D, e.g., with CODA pseudo-2D meshes). The dimension used as reference is the one of the first point. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type for real numbers </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>First point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Second point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The squared Euclidean distance between the two points </dd></dl>

</div>
</div>
<a id="ab712cf58df5dacc470f08332abdde7ec" name="ab712cf58df5dacc470f08332abdde7ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab712cf58df5dacc470f08332abdde7ec">&#9670;&#160;</a></span>vector_of_first_elements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAContainerPairType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; typename CoMMAContainerPairType::value_type::first_type &gt; comma::vector_of_first_elements </td>
          <td>(</td>
          <td class="paramtype">const CoMMAContainerPairType &amp;&#160;</td>
          <td class="paramname"><em>cont</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a container of pairs, return a vector with first elements only. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CoMMAContainerPairType</td><td>Type of the input container </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cont</td><td>A container of pairs from which the first elements will be extracted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first elements of each pair </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a75164a303f92061683959fa690d67906" name="a75164a303f92061683959fa690d67906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75164a303f92061683959fa690d67906">&#9670;&#160;</a></span>deviate_thresh</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr double comma::deviate_thresh = 0.9396926207859084</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Threshold used in combination with a dot product to tell whether two vector deviate. It is set to <picture><source srcset="form_4_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \cos(20^\circ) $" src="form_4.png"/></picture>. </p>

</div>
</div>
<a id="ae843c64bc9e371bd460fe8d040c80e2b" name="ae843c64bc9e371bd460fe8d040c80e2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae843c64bc9e371bd460fe8d040c80e2b">&#9670;&#160;</a></span>iter_agglo_max_iter</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr CoMMAIntT comma::iter_agglo_max_iter = 4</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum allowed iterations for the iterative algorithm, see <a class="el" href="classcomma_1_1_agglomerator___iterative.html">Agglomerator_Iterative</a>. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacecomma.html">comma</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
