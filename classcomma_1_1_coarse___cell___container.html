<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CoMMA: comma::Coarse_Cell_Container&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo-CoMMA_70x70.jpg"/></td>
  <td id="projectalign">
   <div id="projectname">CoMMA<span id="projectnumber">&#160;1.3.1</span>
   </div>
   <div id="projectbrief">A geometric agglomerator for unstructured meshes</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classcomma_1_1_coarse___cell___container.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classcomma_1_1_coarse___cell___container-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">comma::Coarse_Cell_Container&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Class implementing a custom container where the coarse cells are stored.  
 <a href="classcomma_1_1_coarse___cell___container.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_coarse___cell___container_8h_source.html">Coarse_Cell_Container.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a909799f8910487259a0ebee59186b286"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_coarse___cell___container.html#a909799f8910487259a0ebee59186b286">CoarseCellType</a> = <a class="el" href="classcomma_1_1_coarse___cell.html">Coarse_Cell</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;</td></tr>
<tr class="memdesc:a909799f8910487259a0ebee59186b286"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for a <a class="el" href="classcomma_1_1_coarse___cell.html" title="Class describing a coarse cell.">Coarse_Cell</a> object.  <a href="classcomma_1_1_coarse___cell___container.html#a909799f8910487259a0ebee59186b286">More...</a><br /></td></tr>
<tr class="separator:a909799f8910487259a0ebee59186b286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4670588ea6b7292b0ef8760f589eece4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_coarse___cell___container.html#a4670588ea6b7292b0ef8760f589eece4">CoarseCellPtr</a> = std::shared_ptr&lt; <a class="el" href="classcomma_1_1_coarse___cell___container.html#a909799f8910487259a0ebee59186b286">CoarseCellType</a> &gt;</td></tr>
<tr class="memdesc:a4670588ea6b7292b0ef8760f589eece4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for a shared pointer to a <a class="el" href="classcomma_1_1_dual___graph.html" title="A class implementing the CRS global graph representation of the global mesh.">Dual_Graph</a> object.  <a href="classcomma_1_1_coarse___cell___container.html#a4670588ea6b7292b0ef8760f589eece4">More...</a><br /></td></tr>
<tr class="separator:a4670588ea6b7292b0ef8760f589eece4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5051b74d460fe27476950f53a5fd2229"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_coarse___cell___container.html#a5051b74d460fe27476950f53a5fd2229">DualGraphPtr</a> = typename <a class="el" href="classcomma_1_1_coarse___cell.html#a35ecf0c52bb9edbc441d78a43279ca30">CoarseCellType::DualGraphPtr</a></td></tr>
<tr class="memdesc:a5051b74d460fe27476950f53a5fd2229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for a shared pointer to a <a class="el" href="classcomma_1_1_dual___graph.html" title="A class implementing the CRS global graph representation of the global mesh.">Dual_Graph</a> object.  <a href="classcomma_1_1_coarse___cell___container.html#a5051b74d460fe27476950f53a5fd2229">More...</a><br /></td></tr>
<tr class="separator:a5051b74d460fe27476950f53a5fd2229"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aca19a5b3b66ea0d481b315ff012a7725"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_coarse___cell___container.html#aca19a5b3b66ea0d481b315ff012a7725">Coarse_Cell_Container</a> (<a class="el" href="classcomma_1_1_coarse___cell___container.html#a5051b74d460fe27476950f53a5fd2229">DualGraphPtr</a> &amp;fc_graph, const CoMMAIntType singular_card_thresh)</td></tr>
<tr class="memdesc:aca19a5b3b66ea0d481b315ff012a7725"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classcomma_1_1_coarse___cell___container.html" title="Class implementing a custom container where the coarse cells are stored.">Coarse_Cell_Container</a>.  <a href="classcomma_1_1_coarse___cell___container.html#aca19a5b3b66ea0d481b315ff012a7725">More...</a><br /></td></tr>
<tr class="separator:aca19a5b3b66ea0d481b315ff012a7725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac64a40e0897db7510ba5e5b874891268"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_coarse___cell___container.html#ac64a40e0897db7510ba5e5b874891268">~Coarse_Cell_Container</a> ()=default</td></tr>
<tr class="memdesc:ac64a40e0897db7510ba5e5b874891268"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classcomma_1_1_coarse___cell___container.html#ac64a40e0897db7510ba5e5b874891268">More...</a><br /></td></tr>
<tr class="separator:ac64a40e0897db7510ba5e5b874891268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b86f5bf928b038c490f27c1e26bd64"><td class="memItemLeft" align="right" valign="top">CoMMAIndexType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_coarse___cell___container.html#a74b86f5bf928b038c490f27c1e26bd64">get_number_of_fc_agglomerated</a> () const</td></tr>
<tr class="memdesc:a74b86f5bf928b038c490f27c1e26bd64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to get the member variable that defines the number of agglomerated fine cells.  <a href="classcomma_1_1_coarse___cell___container.html#a74b86f5bf928b038c490f27c1e26bd64">More...</a><br /></td></tr>
<tr class="separator:a74b86f5bf928b038c490f27c1e26bd64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e57abc220fb85877b92ad7a7be0b540"><td class="memItemLeft" align="right" valign="top">CoMMAIndexType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_coarse___cell___container.html#a7e57abc220fb85877b92ad7a7be0b540">get_nb_of_cc</a> () const</td></tr>
<tr class="memdesc:a7e57abc220fb85877b92ad7a7be0b540"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to get the number of coarse cells.  <a href="classcomma_1_1_coarse___cell___container.html#a7e57abc220fb85877b92ad7a7be0b540">More...</a><br /></td></tr>
<tr class="separator:a7e57abc220fb85877b92ad7a7be0b540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfc1c9ae9a17a20cc98d26e1d94753ce"><td class="memItemLeft" align="right" valign="top">std::set&lt; CoMMAIndexType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_coarse___cell___container.html#adfc1c9ae9a17a20cc98d26e1d94753ce">get_neighs_cc</a> (const CoMMAIndexType &amp;i_fc, const CoMMAIndexType &amp;i_cc) const</td></tr>
<tr class="memdesc:adfc1c9ae9a17a20cc98d26e1d94753ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the indexes of the neighbouring coarse cells to a given fine cell in a coarse cell (excluding the given coarse cell in which the fine cell is)  <a href="classcomma_1_1_coarse___cell___container.html#adfc1c9ae9a17a20cc98d26e1d94753ce">More...</a><br /></td></tr>
<tr class="separator:adfc1c9ae9a17a20cc98d26e1d94753ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af30a16e10cd4cbcfa2837a36a5a80599"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_coarse___cell___container.html#af30a16e10cd4cbcfa2837a36a5a80599">correct</a> (const CoMMAIntType max_card)</td></tr>
<tr class="memdesc:af30a16e10cd4cbcfa2837a36a5a80599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the correction. In this version it implements the correction of singular cells (if one cell is alone after the agglomeration step is agglomerated to a neighbouring cell)  <a href="classcomma_1_1_coarse___cell___container.html#af30a16e10cd4cbcfa2837a36a5a80599">More...</a><br /></td></tr>
<tr class="separator:af30a16e10cd4cbcfa2837a36a5a80599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06433ef8fe9388f3e640f3d8bfdf7c27"><td class="memItemLeft" align="right" valign="top">std::optional&lt; CoMMAIndexType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_coarse___cell___container.html#a06433ef8fe9388f3e640f3d8bfdf7c27">select_best_cc_to_agglomerate_whole</a> (const std::unordered_set&lt; CoMMAIndexType &gt; &amp;fcs, const std::set&lt; CoMMAIndexType &gt; &amp;neighs, const CoMMAIntType max_card, std::optional&lt; CoMMAIntType &gt; &amp;new_compactness) const</td></tr>
<tr class="memdesc:a06433ef8fe9388f3e640f3d8bfdf7c27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Choose among the neighbouring coarse cells, the one to which a singular coarse cell should be assigned to. This function is similar to <a class="el" href="classcomma_1_1_coarse___cell___container.html#a7211f3bedde3f2f93044cbacd3e47c19">select_best_cc_to_agglomerate</a> but considers only the compactness and the cardinality.  <a href="classcomma_1_1_coarse___cell___container.html#a06433ef8fe9388f3e640f3d8bfdf7c27">More...</a><br /></td></tr>
<tr class="separator:a06433ef8fe9388f3e640f3d8bfdf7c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7211f3bedde3f2f93044cbacd3e47c19"><td class="memItemLeft" align="right" valign="top">std::optional&lt; CoMMAIndexType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_coarse___cell___container.html#a7211f3bedde3f2f93044cbacd3e47c19">select_best_cc_to_agglomerate</a> (const CoMMAIndexType fc, const std::set&lt; CoMMAIndexType &gt; &amp;neighs, const CoMMAIntType max_card, std::optional&lt; CoMMAIntType &gt; &amp;new_compactness) const</td></tr>
<tr class="memdesc:a7211f3bedde3f2f93044cbacd3e47c19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Choose among the neighbouring coarse cells, the one to which a fine cell should be assigned to. We prefer the coarse cell which shares the most faces with the fine cell. Otherwise, we look at the cardinality and choose the coarse cell with the smallest one.  <a href="classcomma_1_1_coarse___cell___container.html#a7211f3bedde3f2f93044cbacd3e47c19">More...</a><br /></td></tr>
<tr class="separator:a7211f3bedde3f2f93044cbacd3e47c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93ab43e7ab6288a9e7d6fa00e7d53c3d"><td class="memItemLeft" align="right" valign="top">CoMMAIntType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_coarse___cell___container.html#a93ab43e7ab6288a9e7d6fa00e7d53c3d">get_shared_faces</a> (const CoMMAIndexType fc, const <a class="el" href="classcomma_1_1_coarse___cell___container.html#a4670588ea6b7292b0ef8760f589eece4">CoarseCellPtr</a> cc) const</td></tr>
<tr class="memdesc:a93ab43e7ab6288a9e7d6fa00e7d53c3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the number of faces shared between a fine cell and a coarse one.  <a href="classcomma_1_1_coarse___cell___container.html#a93ab43e7ab6288a9e7d6fa00e7d53c3d">More...</a><br /></td></tr>
<tr class="separator:a93ab43e7ab6288a9e7d6fa00e7d53c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a745d1b842ec7a43dbe303cbef43a0b80"><td class="memItemLeft" align="right" valign="top">CoMMAIndexType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_coarse___cell___container.html#a745d1b842ec7a43dbe303cbef43a0b80">create_cc</a> (const std::unordered_set&lt; CoMMAIndexType &gt; &amp;s_fc, const CoMMAIntType compactness, bool is_anisotropic=false, bool is_creation_delayed=false)</td></tr>
<tr class="memdesc:a745d1b842ec7a43dbe303cbef43a0b80"><td class="mdescLeft">&#160;</td><td class="mdescRight">It creates a coarse cell based on the set of fine cells given as input.  <a href="classcomma_1_1_coarse___cell___container.html#a745d1b842ec7a43dbe303cbef43a0b80">More...</a><br /></td></tr>
<tr class="separator:a745d1b842ec7a43dbe303cbef43a0b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff375cbd38f430300abad77480031841"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_coarse___cell___container.html#aff375cbd38f430300abad77480031841">cc_create_all_delayed_cc</a> ()</td></tr>
<tr class="memdesc:aff375cbd38f430300abad77480031841"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates all the delayed coarse cell. It works only when the delayed cell flag is activated in the agglomerator.  <a href="classcomma_1_1_coarse___cell___container.html#aff375cbd38f430300abad77480031841">More...</a><br /></td></tr>
<tr class="separator:aff375cbd38f430300abad77480031841"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a00994ecc5f6dae2f9ab6bb376e50931a"><td class="memItemLeft" align="right" valign="top">std::map&lt; CoMMAIndexType, <a class="el" href="classcomma_1_1_coarse___cell___container.html#a4670588ea6b7292b0ef8760f589eece4">CoarseCellPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_coarse___cell___container.html#a00994ecc5f6dae2f9ab6bb376e50931a">_ccs</a></td></tr>
<tr class="memdesc:a00994ecc5f6dae2f9ab6bb376e50931a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map containing the CC and their ID.  <a href="classcomma_1_1_coarse___cell___container.html#a00994ecc5f6dae2f9ab6bb376e50931a">More...</a><br /></td></tr>
<tr class="separator:a00994ecc5f6dae2f9ab6bb376e50931a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86e1e85dcd0d95bfd49a267960d4ea58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcomma_1_1_coarse___cell___container.html#a5051b74d460fe27476950f53a5fd2229">DualGraphPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_coarse___cell___container.html#a86e1e85dcd0d95bfd49a267960d4ea58">_fc_graph</a></td></tr>
<tr class="memdesc:a86e1e85dcd0d95bfd49a267960d4ea58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dual graph representation.  <a href="classcomma_1_1_coarse___cell___container.html#a86e1e85dcd0d95bfd49a267960d4ea58">More...</a><br /></td></tr>
<tr class="separator:a86e1e85dcd0d95bfd49a267960d4ea58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cd32093348aa15c437952de4fb50c20"><td class="memItemLeft" align="right" valign="top">CoMMAIndexType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_coarse___cell___container.html#a5cd32093348aa15c437952de4fb50c20">_cc_counter</a></td></tr>
<tr class="memdesc:a5cd32093348aa15c437952de4fb50c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of coarse cells.  <a href="classcomma_1_1_coarse___cell___container.html#a5cd32093348aa15c437952de4fb50c20">More...</a><br /></td></tr>
<tr class="separator:a5cd32093348aa15c437952de4fb50c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4552eff1fb2fb15974b835d765b61e4b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::optional&lt; CoMMAIndexType &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_coarse___cell___container.html#a4552eff1fb2fb15974b835d765b61e4b">_fc_2_cc</a></td></tr>
<tr class="memdesc:a4552eff1fb2fb15974b835d765b61e4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output vector identifying to which coarse cell the fine cell belongs.  <a href="classcomma_1_1_coarse___cell___container.html#a4552eff1fb2fb15974b835d765b61e4b">More...</a><br /></td></tr>
<tr class="separator:a4552eff1fb2fb15974b835d765b61e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d4a556613699b7ab500717238bd7cf9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_coarse___cell___container.html#a7d4a556613699b7ab500717238bd7cf9">_is_fc_agglomerated</a></td></tr>
<tr class="memdesc:a7d4a556613699b7ab500717238bd7cf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of boolean telling whether a fine cell has been agglomerated.  <a href="classcomma_1_1_coarse___cell___container.html#a7d4a556613699b7ab500717238bd7cf9">More...</a><br /></td></tr>
<tr class="separator:a7d4a556613699b7ab500717238bd7cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a337440485655e84a57e8a7e9d1d3ca8f"><td class="memItemLeft" align="right" valign="top">CoMMAIntType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_coarse___cell___container.html#a337440485655e84a57e8a7e9d1d3ca8f">_sing_card_thresh</a></td></tr>
<tr class="memdesc:a337440485655e84a57e8a7e9d1d3ca8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum cardinality for receiver CC when correcting.  <a href="classcomma_1_1_coarse___cell___container.html#a337440485655e84a57e8a7e9d1d3ca8f">More...</a><br /></td></tr>
<tr class="separator:a337440485655e84a57e8a7e9d1d3ca8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a16e9f6a6002a7a3580b7f1d017a15b99"><td class="memItemLeft" align="right" valign="top">CoMMAIndexType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_coarse___cell___container.html#a16e9f6a6002a7a3580b7f1d017a15b99">_nb_of_agglomerated_fc</a> = 0</td></tr>
<tr class="memdesc:a16e9f6a6002a7a3580b7f1d017a15b99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of agglomerated fine cells.  <a href="classcomma_1_1_coarse___cell___container.html#a16e9f6a6002a7a3580b7f1d017a15b99">More...</a><br /></td></tr>
<tr class="separator:a16e9f6a6002a7a3580b7f1d017a15b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3524485e16d28d4eda3cac529a882ae6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::unordered_set&lt; CoMMAIndexType &gt;, CoMMAIntType &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_coarse___cell___container.html#a3524485e16d28d4eda3cac529a882ae6">_delayed_cc</a></td></tr>
<tr class="memdesc:a3524485e16d28d4eda3cac529a882ae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of the set of fine cells composing the too small coarse cells that will be built at the end of the agglomeration process and their compactness degree.  <a href="classcomma_1_1_coarse___cell___container.html#a3524485e16d28d4eda3cac529a882ae6">More...</a><br /></td></tr>
<tr class="separator:a3524485e16d28d4eda3cac529a882ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08300d61da9f6559f580b29003e1f689"><td class="memItemLeft" align="right" valign="top">std::deque&lt; CoMMAIndexType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomma_1_1_coarse___cell___container.html#a08300d61da9f6559f580b29003e1f689">_singular_cc</a></td></tr>
<tr class="memdesc:a08300d61da9f6559f580b29003e1f689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of singular coarse cells, that is, composed of only one fine cell.  <a href="classcomma_1_1_coarse___cell___container.html#a08300d61da9f6559f580b29003e1f689">More...</a><br /></td></tr>
<tr class="separator:a08300d61da9f6559f580b29003e1f689"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename CoMMAIndexType, typename CoMMAWeightType, typename CoMMAIntType&gt;<br />
class comma::Coarse_Cell_Container&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;</div><p >Class implementing a custom container where the coarse cells are stored. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CoMMAIndexType</td><td>the CoMMA index type for the global index of the mesh </td></tr>
    <tr><td class="paramname">CoMMAWeightType</td><td>the CoMMA weight type for the weights (volume or area) of the nodes or edges of the Mesh </td></tr>
    <tr><td class="paramname">CoMMAIntType</td><td>the CoMMA type for integers </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a4670588ea6b7292b0ef8760f589eece4" name="a4670588ea6b7292b0ef8760f589eece4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4670588ea6b7292b0ef8760f589eece4">&#9670;&#160;</a></span>CoarseCellPtr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomma_1_1_coarse___cell___container.html">comma::Coarse_Cell_Container</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;::CoarseCellPtr =  std::shared_ptr&lt;<a class="el" href="classcomma_1_1_coarse___cell___container.html#a909799f8910487259a0ebee59186b286">CoarseCellType</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for a shared pointer to a <a class="el" href="classcomma_1_1_dual___graph.html" title="A class implementing the CRS global graph representation of the global mesh.">Dual_Graph</a> object. </p>

</div>
</div>
<a id="a909799f8910487259a0ebee59186b286" name="a909799f8910487259a0ebee59186b286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a909799f8910487259a0ebee59186b286">&#9670;&#160;</a></span>CoarseCellType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomma_1_1_coarse___cell___container.html">comma::Coarse_Cell_Container</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;::CoarseCellType =  <a class="el" href="classcomma_1_1_coarse___cell.html">Coarse_Cell</a>&lt;CoMMAIndexType, CoMMAWeightType, CoMMAIntType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for a <a class="el" href="classcomma_1_1_coarse___cell.html" title="Class describing a coarse cell.">Coarse_Cell</a> object. </p>

</div>
</div>
<a id="a5051b74d460fe27476950f53a5fd2229" name="a5051b74d460fe27476950f53a5fd2229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5051b74d460fe27476950f53a5fd2229">&#9670;&#160;</a></span>DualGraphPtr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomma_1_1_coarse___cell___container.html">comma::Coarse_Cell_Container</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;::DualGraphPtr =  typename <a class="el" href="classcomma_1_1_coarse___cell.html#a35ecf0c52bb9edbc441d78a43279ca30">CoarseCellType::DualGraphPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for a shared pointer to a <a class="el" href="classcomma_1_1_dual___graph.html" title="A class implementing the CRS global graph representation of the global mesh.">Dual_Graph</a> object. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aca19a5b3b66ea0d481b315ff012a7725" name="aca19a5b3b66ea0d481b315ff012a7725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca19a5b3b66ea0d481b315ff012a7725">&#9670;&#160;</a></span>Coarse_Cell_Container()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcomma_1_1_coarse___cell___container.html">comma::Coarse_Cell_Container</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;::Coarse_Cell_Container </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcomma_1_1_coarse___cell___container.html#a5051b74d460fe27476950f53a5fd2229">DualGraphPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>fc_graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CoMMAIntType&#160;</td>
          <td class="paramname"><em>singular_card_thresh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a <a class="el" href="classcomma_1_1_coarse___cell___container.html" title="Class implementing a custom container where the coarse cells are stored.">Coarse_Cell_Container</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fc_graph</td><td>Input element <a class="el" href="classcomma_1_1_dual___graph.html" title="A class implementing the CRS global graph representation of the global mesh.">Dual_Graph</a> to work on the seeds choice and the seeds pool </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">singular_card_thresh</td><td>Threshold value below which a coarse cell is considered singular </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac64a40e0897db7510ba5e5b874891268" name="ac64a40e0897db7510ba5e5b874891268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac64a40e0897db7510ba5e5b874891268">&#9670;&#160;</a></span>~Coarse_Cell_Container()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcomma_1_1_coarse___cell___container.html">comma::Coarse_Cell_Container</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;::~<a class="el" href="classcomma_1_1_coarse___cell___container.html">Coarse_Cell_Container</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aff375cbd38f430300abad77480031841" name="aff375cbd38f430300abad77480031841"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff375cbd38f430300abad77480031841">&#9670;&#160;</a></span>cc_create_all_delayed_cc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomma_1_1_coarse___cell___container.html">comma::Coarse_Cell_Container</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;::cc_create_all_delayed_cc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates all the delayed coarse cell. It works only when the delayed cell flag is activated in the agglomerator. </p>

</div>
</div>
<a id="af30a16e10cd4cbcfa2837a36a5a80599" name="af30a16e10cd4cbcfa2837a36a5a80599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af30a16e10cd4cbcfa2837a36a5a80599">&#9670;&#160;</a></span>correct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomma_1_1_coarse___cell___container.html">comma::Coarse_Cell_Container</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;::correct </td>
          <td>(</td>
          <td class="paramtype">const CoMMAIntType&#160;</td>
          <td class="paramname"><em>max_card</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of the correction. In this version it implements the correction of singular cells (if one cell is alone after the agglomeration step is agglomerated to a neighbouring cell) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_card</td><td>Maximum cardinality allowed (CoMMA might still be beyond this value) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a745d1b842ec7a43dbe303cbef43a0b80" name="a745d1b842ec7a43dbe303cbef43a0b80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a745d1b842ec7a43dbe303cbef43a0b80">&#9670;&#160;</a></span>create_cc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CoMMAIndexType <a class="el" href="classcomma_1_1_coarse___cell___container.html">comma::Coarse_Cell_Container</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;::create_cc </td>
          <td>(</td>
          <td class="paramtype">const std::unordered_set&lt; CoMMAIndexType &gt; &amp;&#160;</td>
          <td class="paramname"><em>s_fc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CoMMAIntType&#160;</td>
          <td class="paramname"><em>compactness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_anisotropic</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_creation_delayed</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>It creates a coarse cell based on the set of fine cells given as input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s_fc</td><td>Set of fine cells passed as a reference </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compactness</td><td>Compactness degree of the CC </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_anisotropic</td><td>Boolean that tells if we are in an anisotropic case or not </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_creation_delayed</td><td>Based on the agglomerator instruction we define if we delay or not the agglomeration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Global identifier of the coarse cell </dd></dl>

</div>
</div>
<a id="a7e57abc220fb85877b92ad7a7be0b540" name="a7e57abc220fb85877b92ad7a7be0b540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e57abc220fb85877b92ad7a7be0b540">&#9670;&#160;</a></span>get_nb_of_cc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CoMMAIndexType <a class="el" href="classcomma_1_1_coarse___cell___container.html">comma::Coarse_Cell_Container</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;::get_nb_of_cc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper to get the number of coarse cells. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of coarse cells created so far </dd></dl>

</div>
</div>
<a id="adfc1c9ae9a17a20cc98d26e1d94753ce" name="adfc1c9ae9a17a20cc98d26e1d94753ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfc1c9ae9a17a20cc98d26e1d94753ce">&#9670;&#160;</a></span>get_neighs_cc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; CoMMAIndexType &gt; <a class="el" href="classcomma_1_1_coarse___cell___container.html">comma::Coarse_Cell_Container</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;::get_neighs_cc </td>
          <td>(</td>
          <td class="paramtype">const CoMMAIndexType &amp;&#160;</td>
          <td class="paramname"><em>i_fc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CoMMAIndexType &amp;&#160;</td>
          <td class="paramname"><em>i_cc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the indexes of the neighbouring coarse cells to a given fine cell in a coarse cell (excluding the given coarse cell in which the fine cell is) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i_fc</td><td>index of the fine cell inside the coarse cell to be analysed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i_cc</td><td>index of the coarse cell in which the fine cell is in </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of the index of the coarse cells </dd></dl>

</div>
</div>
<a id="a74b86f5bf928b038c490f27c1e26bd64" name="a74b86f5bf928b038c490f27c1e26bd64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74b86f5bf928b038c490f27c1e26bd64">&#9670;&#160;</a></span>get_number_of_fc_agglomerated()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CoMMAIndexType <a class="el" href="classcomma_1_1_coarse___cell___container.html">comma::Coarse_Cell_Container</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;::get_number_of_fc_agglomerated </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper to get the member variable that defines the number of agglomerated fine cells. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of fine cells agglomerated so far </dd></dl>

</div>
</div>
<a id="a93ab43e7ab6288a9e7d6fa00e7d53c3d" name="a93ab43e7ab6288a9e7d6fa00e7d53c3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93ab43e7ab6288a9e7d6fa00e7d53c3d">&#9670;&#160;</a></span>get_shared_faces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CoMMAIntType <a class="el" href="classcomma_1_1_coarse___cell___container.html">comma::Coarse_Cell_Container</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;::get_shared_faces </td>
          <td>(</td>
          <td class="paramtype">const CoMMAIndexType&#160;</td>
          <td class="paramname"><em>fc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcomma_1_1_coarse___cell___container.html#a4670588ea6b7292b0ef8760f589eece4">CoarseCellPtr</a>&#160;</td>
          <td class="paramname"><em>cc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the number of faces shared between a fine cell and a coarse one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fc</td><td>Index of the fine cell </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cc</td><td>Pointer to the coarse cell </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of shared faces </dd></dl>

</div>
</div>
<a id="a7211f3bedde3f2f93044cbacd3e47c19" name="a7211f3bedde3f2f93044cbacd3e47c19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7211f3bedde3f2f93044cbacd3e47c19">&#9670;&#160;</a></span>select_best_cc_to_agglomerate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; CoMMAIndexType &gt; <a class="el" href="classcomma_1_1_coarse___cell___container.html">comma::Coarse_Cell_Container</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;::select_best_cc_to_agglomerate </td>
          <td>(</td>
          <td class="paramtype">const CoMMAIndexType&#160;</td>
          <td class="paramname"><em>fc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; CoMMAIndexType &gt; &amp;&#160;</td>
          <td class="paramname"><em>neighs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CoMMAIntType&#160;</td>
          <td class="paramname"><em>max_card</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; CoMMAIntType &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_compactness</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Choose among the neighbouring coarse cells, the one to which a fine cell should be assigned to. We prefer the coarse cell which shares the most faces with the fine cell. Otherwise, we look at the cardinality and choose the coarse cell with the smallest one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fc</td><td>Index of the fine cell </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">neighs</td><td>Neighbouring coarse cells </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_card</td><td>Maximum cardinality allowed (CoMMA might still go beyond this value) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">new_compactness</td><td>Compactness degree of the CC if the result would to be added </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the chosen coarse cell </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd><code>max_card</code> might not be honored </dd></dl>

</div>
</div>
<a id="a06433ef8fe9388f3e640f3d8bfdf7c27" name="a06433ef8fe9388f3e640f3d8bfdf7c27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06433ef8fe9388f3e640f3d8bfdf7c27">&#9670;&#160;</a></span>select_best_cc_to_agglomerate_whole()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; CoMMAIndexType &gt; <a class="el" href="classcomma_1_1_coarse___cell___container.html">comma::Coarse_Cell_Container</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;::select_best_cc_to_agglomerate_whole </td>
          <td>(</td>
          <td class="paramtype">const std::unordered_set&lt; CoMMAIndexType &gt; &amp;&#160;</td>
          <td class="paramname"><em>fcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; CoMMAIndexType &gt; &amp;&#160;</td>
          <td class="paramname"><em>neighs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CoMMAIntType&#160;</td>
          <td class="paramname"><em>max_card</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; CoMMAIntType &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_compactness</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Choose among the neighbouring coarse cells, the one to which a singular coarse cell should be assigned to. This function is similar to <a class="el" href="classcomma_1_1_coarse___cell___container.html#a7211f3bedde3f2f93044cbacd3e47c19">select_best_cc_to_agglomerate</a> but considers only the compactness and the cardinality. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fcs</td><td>Set of indices of the fine cells composing the coarse cell to be agglomerated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">neighs</td><td>Neighbouring coarse cells </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_card</td><td>Maximum cardinality allowed (CoMMA might still go beyond this value) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">new_compactness</td><td>Compactness degree of the CC if the result would to be added </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the chosen coarse cell </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd><code>max_card</code> might not be honored </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a5cd32093348aa15c437952de4fb50c20" name="a5cd32093348aa15c437952de4fb50c20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cd32093348aa15c437952de4fb50c20">&#9670;&#160;</a></span>_cc_counter</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CoMMAIndexType <a class="el" href="classcomma_1_1_coarse___cell___container.html">comma::Coarse_Cell_Container</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;::_cc_counter</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of coarse cells. </p>

</div>
</div>
<a id="a00994ecc5f6dae2f9ab6bb376e50931a" name="a00994ecc5f6dae2f9ab6bb376e50931a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00994ecc5f6dae2f9ab6bb376e50931a">&#9670;&#160;</a></span>_ccs</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;CoMMAIndexType, <a class="el" href="classcomma_1_1_coarse___cell___container.html#a4670588ea6b7292b0ef8760f589eece4">CoarseCellPtr</a>&gt; <a class="el" href="classcomma_1_1_coarse___cell___container.html">comma::Coarse_Cell_Container</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;::_ccs</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map containing the CC and their ID. </p>

</div>
</div>
<a id="a3524485e16d28d4eda3cac529a882ae6" name="a3524485e16d28d4eda3cac529a882ae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3524485e16d28d4eda3cac529a882ae6">&#9670;&#160;</a></span>_delayed_cc</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;std::unordered_set&lt;CoMMAIndexType&gt;, CoMMAIntType&gt; &gt; <a class="el" href="classcomma_1_1_coarse___cell___container.html">comma::Coarse_Cell_Container</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;::_delayed_cc</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector of the set of fine cells composing the too small coarse cells that will be built at the end of the agglomeration process and their compactness degree. </p>

</div>
</div>
<a id="a4552eff1fb2fb15974b835d765b61e4b" name="a4552eff1fb2fb15974b835d765b61e4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4552eff1fb2fb15974b835d765b61e4b">&#9670;&#160;</a></span>_fc_2_cc</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::optional&lt;CoMMAIndexType&gt; &gt; <a class="el" href="classcomma_1_1_coarse___cell___container.html">comma::Coarse_Cell_Container</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;::_fc_2_cc</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output vector identifying to which coarse cell the fine cell belongs. </p>

</div>
</div>
<a id="a86e1e85dcd0d95bfd49a267960d4ea58" name="a86e1e85dcd0d95bfd49a267960d4ea58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86e1e85dcd0d95bfd49a267960d4ea58">&#9670;&#160;</a></span>_fc_graph</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcomma_1_1_coarse___cell___container.html#a5051b74d460fe27476950f53a5fd2229">DualGraphPtr</a> <a class="el" href="classcomma_1_1_coarse___cell___container.html">comma::Coarse_Cell_Container</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;::_fc_graph</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dual graph representation. </p>

</div>
</div>
<a id="a7d4a556613699b7ab500717238bd7cf9" name="a7d4a556613699b7ab500717238bd7cf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d4a556613699b7ab500717238bd7cf9">&#9670;&#160;</a></span>_is_fc_agglomerated</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;bool&gt; <a class="el" href="classcomma_1_1_coarse___cell___container.html">comma::Coarse_Cell_Container</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;::_is_fc_agglomerated</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vector of boolean telling whether a fine cell has been agglomerated. </p>

</div>
</div>
<a id="a16e9f6a6002a7a3580b7f1d017a15b99" name="a16e9f6a6002a7a3580b7f1d017a15b99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16e9f6a6002a7a3580b7f1d017a15b99">&#9670;&#160;</a></span>_nb_of_agglomerated_fc</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CoMMAIndexType <a class="el" href="classcomma_1_1_coarse___cell___container.html">comma::Coarse_Cell_Container</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;::_nb_of_agglomerated_fc = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of agglomerated fine cells. </p>

</div>
</div>
<a id="a337440485655e84a57e8a7e9d1d3ca8f" name="a337440485655e84a57e8a7e9d1d3ca8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a337440485655e84a57e8a7e9d1d3ca8f">&#9670;&#160;</a></span>_sing_card_thresh</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CoMMAIntType <a class="el" href="classcomma_1_1_coarse___cell___container.html">comma::Coarse_Cell_Container</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;::_sing_card_thresh</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimum cardinality for receiver CC when correcting. </p>

</div>
</div>
<a id="a08300d61da9f6559f580b29003e1f689" name="a08300d61da9f6559f580b29003e1f689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08300d61da9f6559f580b29003e1f689">&#9670;&#160;</a></span>_singular_cc</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoMMAIndexType , typename CoMMAWeightType , typename CoMMAIntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt;CoMMAIndexType&gt; <a class="el" href="classcomma_1_1_coarse___cell___container.html">comma::Coarse_Cell_Container</a>&lt; CoMMAIndexType, CoMMAWeightType, CoMMAIntType &gt;::_singular_cc</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set of singular coarse cells, that is, composed of only one fine cell. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/CoMMA/<a class="el" href="_coarse___cell___container_8h_source.html">Coarse_Cell_Container.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacecomma.html">comma</a></li><li class="navelem"><a class="el" href="classcomma_1_1_coarse___cell___container.html">Coarse_Cell_Container</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
